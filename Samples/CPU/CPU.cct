// 8-bit RISC CPU
// By John Hodge (thePowersGang)
// Designed in LogicCircuit
%include "memory.cct"
%include "../adder.cct"
%include "../subber_8bit.cct"

%define	NUM_GPR_BITS	8
%define	NUM_ADDR_BITS	16

#array mem_data_in NUM_GPR_BITS
#array mem_data_out NUM_GPR_BITS
#array reg_data_in NUM_GPR_BITS
#array reg_data_out NUM_GPR_BITS
#array mem_addr NUM_ADDR_BITS
#array reg_addr 4
#array reg_select	16

#array reg_pc_in	NUM_ADDR_BITS
#array reg_pc_out	NUM_ADDR_BITS

#array stage_num	4
#array stage_state	16

#array add_temp	NUM_GPR_BITS

#array addr	NUM_ADDR_BITS
#array instr	8
#array val	NUM_GPR_BITS

#breakpoint (DELAY{2} $next_stage) "Next Stage"
#breakpoint $reg_pc_write "PC Write"
#breakpoint $stage_reset "Stage Reset"

#display 1 "Clock " $clock
#display 1 "Stage " @stage_state
#display 1 "Reset " $stage_reset
#display 1 "NextS " $next_stage
#display 1 "PC    " @reg_pc_in
#display 1 "Opcode" @instr
#display 1 "NextI " $next_instruction

#display 1 "MemEn " $mem_enable
#display $mem_enable "MemAddr" @mem_addr
#display $mem_write "MemOut " @mem_data_out
#display 1 "MemRdy" $mem_ready
#display $mem_ready "MemIn  " @mem_data_in
#display 1 "RegRdy" $reg_ready

#display $is_XOR "Op - XOR A, r" @instr[0], @instr[1], @instr[2], @instr[3]
#display $is_OR  "Op - OR  A, r" @instr[0], @instr[1], @instr[2], @instr[3]
#display $is_AND "Op - AND A, r" @instr[0], @instr[1], @instr[2], @instr[3]
#display $is_ADD "Op - ADD A, r" @instr[0], @instr[1], @instr[2], @instr[3]
#display $is_LOAD  "Op - LOAD  r, [X]" @instr[0], @instr[1], @instr[2], @instr[3]
#display $is_STORE "Op - STORE [X], r" @instr[0], @instr[1], @instr[2], @instr[3]

// Instruction clock (used to ensure synchronisation)
// In each 128 cycles, the clock is high for one
// TODO: Determine how many logic cycles are needed to run the CPU
//       - Maybe have @stage_state[15] map to reset (or map others via an
//         AND with $is_*)
$clock = CLOCK{128}

// === Memory ===
// TODO: Maybe have these lines be arguments of some form
$mem_ready, @mem_data_in = MEMORY_SPACE $mem_enable, @mem_addr, $mem_data_write, @mem_data_out

// === Registers ===
// --- General Purpose Registers ---
// Registers can be accessed directly (by the @reg_*_value groups), or
// by @reg_data_in which is selected using the @reg_addr group
@reg_select = DEMUX{4} $reg_enable, @reg_addr	// Select the register
%assign i 0
%rep 16
#array reg_ %+ i %+ _value NUM_GPR_BITS
#array reg_ %+ i %+ _newvalue NUM_GPR_BITS
$reg_ %+ i %+ _ready, @reg_ %+ i %+ _value = MEMORY_BYTE 1, $reg_ %+ i %+ _write, @reg_ %+ i %+ _newvalue	// Actual Register

$reg_ %+ i %+ _write = AND @reg_select[i], $reg_write	// Get global Write signal
$reg_ready = DELAY{delayof_MEMORY_WORD} @reg_select[i]	// Set global ready signal
 %assign j 0
 %rep NUM_GPR_BITS
@reg_ %+ i %+ _newvalue[j] = AND @reg_select[i], @reg_data_out[j]	// Get global input
@reg_data_in[j] = AND @reg_select[i], @reg_ %+ i %+ _value[j]	// Set global output
 %assign j j+1
 %endrep
%assign i i+1
%endrep
// --- Program Counter ---
#display $reg_pc_write "New PC" @reg_pc_out
$NULL, @reg_pc_in = MEMORY_WORD 1, $reg_pc_write, @reg_pc_out
// --- FLAGS Pseudo-Register ---
$NULL, $flags_C = LATCH 1, $flags_C_clear, $flags_C

// === "Temporary" Latches ===
// @instr, @val and @addr - Temporary "variables" used to hold intermediate values
// to be moved to other locations
@instr = LATCH_BYTE $instr_clear, @instr
@val   = LATCH_BYTE $val_clear, @val
@addr  = LATCH_WORD $addr_clear, @addr
$NULL, $next_instruction  = LATCH 1, $nextinstr_clear, $next_instruction

// === Timing control (stages) ===
// 4-bit counter reset by $stage_reset, incremented by $mem_ready
// Attached to a 4-bit de-mutexer controlling the state of stages
@stage_num = COUNTER{4} $stage_reset, $next_stage
@stage_state = DEMUX{4} 1, @stage_num
; $next_instruction = DELAY $clock
$next_stage = DELAY $mem_ready
$next_stage = DELAY $reg_ready


// === Next instruction ===
$stage_reset = PULSE $next_instruction

// === PC Increment ===
$increment_pc = PULSE $next_instruction
$reg_pc_invalidate = $increment_pc	// Invalidate PC when increment is called
// Add 1 to the PC register (if $increment_pc is set)
// - Assigning to reg_pc_(write|out) causes it to update the register
//   once done
$reg_pc_write, @reg_pc_out, $NULL = ADDER_16BIT ($increment_pc),\
	@reg_pc_in, \
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, \
	0
$reg_pc_valid = DELAY{4} $reg_pc_write	// TODO: Fine tune this to the write delay of a word register
$reg_pc_valid = PULSE 1	// Raise at CPU init
$NULL, $reg_pc_valid  = LATCH 1, $reg_pc_invalidate, $reg_pc_valid

// === Instruction input ===
// STAGE0 - Opcode Fetch
#display @stage_state[0] "Opcode fetch" 1
// Reset all values
$instr_clear = @stage_state[0]	// Clear the instruction cache
$val_clear   = @stage_state[0]	// Clear the value cache
$addr_clear  = @stage_state[0]	// Clear the address cache
// Read opcode from memory
// - Memory read will update the stage to #2
// - ANDing with $reg_pc_valid causes the read to not be attempted until
//   PC is marked as valid
@mem_addr = DELAY (AND{NUM_ADDR_BITS} @stage_state[0], $reg_pc_valid, @reg_pc_in)	// Set memory address to PC
$mem_enable   = PULSE (AND @stage_state[0], $reg_pc_valid)	// Enable memory for read
$increment_pc = PULSE (AND @stage_state[0], $reg_pc_valid)	// Increment the program counter too

// STAGE1 - Instruction fetched, save in latch
#display @stage_state[1] "Instruction Save" @stage_state[1]
@instr = AND{8} @stage_state[1], (DELAY{4} @mem_data_in)	// Save the opcode byte
$next_stage = PULSE (DELAY{3} @stage_state[1])	// Wait for latch to hold and for instructions to decode

// =======================
// === Opcode Decoding ===
// =======================
$is_MOVar  = AND (NOT   @instr[7]), (NOT   @instr[6]), (NOT   @instr[5]), (NOT   @instr[4])	// 0000rrrr
$is_MOVra  = AND (NOT   @instr[7]), (NOT   @instr[6]), (NOT   @instr[5]), (DELAY @instr[4])	// 0001rrrr

$is_LOAD   = AND (NOT   @instr[7]), (NOT   @instr[6]), (DELAY @instr[5]), (NOT   @instr[4])	// 0010rrrr
$is_STORE  = AND (NOT   @instr[7]), (NOT   @instr[6]), (DELAY @instr[5]), (DELAY @instr[4])	// 0011rrrr

$is_JMPcc  = AND (NOT   @instr[7]), (DELAY @instr[6]), (NOT   @instr[5]), (DELAY @instr[4])	// 0101sccc
$is_CALLcc = AND (NOT   @instr[7]), (DELAY @instr[6]), (DELAY @instr[5]), (NOT   @instr[4])	// 0110sccc
$is_RETcc  = AND (NOT   @instr[7]), (DELAY @instr[6]), (DELAY @instr[5]), (DELAY @instr[4]), (NOT   @instr[3])	// 0111 0ccc

$is_ADD    = AND (DELAY @instr[7]), (NOT   @instr[6]), (NOT   @instr[5]), (NOT   @instr[4])	// 1000rrrr
$is_SUB    = AND (DELAY @instr[7]), (NOT   @instr[6]), (NOT   @instr[5]), (DELAY @instr[4])	// 1001rrrr
$is_AND    = AND (DELAY @instr[7]), (NOT   @instr[6]), (DELAY @instr[5]), (NOT   @instr[4])	// 1010rrrr
$is_OR     = AND (DELAY @instr[7]), (NOT   @instr[6]), (DELAY @instr[5]), (DELAY @instr[4])	// 1011rrrr
$is_XOR    = AND (DELAY @instr[7]), (DELAY @instr[6]), (NOT   @instr[5]), (NOT   @instr[4])	// 1100rrrr
$is_SHL    = AND (DELAY @instr[7]), (DELAY @instr[6]), (NOT   @instr[5]), (DELAY @instr[4])	// 1101rrrr

$is_PUSH   = AND (DELAY @instr[7]), (DELAY @instr[6]), (DELAY @instr[5]), (NOT   @instr[4])	// 1110rrrr
$is_POP    = AND (DELAY @instr[7]), (DELAY @instr[6]), (DELAY @instr[5]), (DELAY @instr[4])	// 1111rrrr

// 0111 1xxx
%define misc_mask (NOT   @instr[7]), (DELAY @instr[6]), (DELAY @instr[5]), (DELAY @instr[4]), (DELAY @instr[3])
$is_MISC   = AND misc_mask

// - Misc Functions
$is_NOT_A  = AND misc_mask, (NOT   @instr[2]), (NOT   @instr[1]), (NOT   @instr[0])	// ---- -000
$is_NEG_A  = AND misc_mask, (NOT   @instr[2]), (NOT   @instr[1]), (DELAY @instr[0])	// ---- -001
$is_CLC    = AND misc_mask, (NOT   @instr[2]), (DELAY @instr[1]), (NOT   @instr[0])	// ---- -010
$is_STC    = AND misc_mask, (NOT   @instr[2]), (DELAY @instr[1]), (DELAY @instr[0])	// ---- -011
$is_LDI_A  = AND misc_mask, (DELAY @instr[2]), (NOT   @instr[1]), (NOT   @instr[0])	// ---- -100
$is_LAI_X  = AND misc_mask, (DELAY @instr[2]), (NOT   @instr[1]), (DELAY @instr[0])	// ---- -101
$is_MOV_SP_X  = AND misc_mask, (DELAY @instr[2]), (NOT   @instr[1]), (DELAY @instr[0])	// ---- -101

// === Handle Undefined Opcodes ===
$is_UNDEF = NOT (OR $is_LOAD, $is_STORE, $is_MOVar, $is_MOVra,\
	$is_ADD, $is_AND, $is_OR, $is_XOR,\
	$is_NOT_A, $is_CLC, $is_STC,\
	$is_LDI_A, $is_LAI_X)
; $next_instruction = AND @stage_state[2], $is_UNDEF

// === OPCODES ===
#display @stage_state[2] "Opcode decode" 1

// Branch conditions
$is_r0_zero = NOT (OR @reg_0_value)
$_branch_condition = AND (NOT   @instr[2]), (NOT   @instr[1])	// Unconditional
$_branch_condition = AND (NOT   @instr[2]), (DELAY @instr[1]), $is_r0_zero	// A == 0
$_branch_condition = AND (DELAY @instr[2]), (NOT   @instr[1]), $flags_C	// Carry Set
$_branch_condition = AND (DELAY @instr[2]), (DELAY @instr[1]), @reg_0_value[7]	// Negative
$branch_condition = XOR $_branch_condition, @instr[0]
// Load destination
;@addr = 
// --- JMPcc ---
// TODO
// --- CALLcc ---
// TODO
// --- RETcc ---
// TODO

// --- LOAD ---
// > Read X (R13:R12) into @addr LATCH (Takes 3 cycles to fully complete)
%assign i 0
%rep NUM_GPR_BITS
@addr[i] = AND $is_STORE, @stage_state[3], @reg_12_value[i]	// R12
%assign i i+1
%endrep
%assign j 0
%rep NUM_GPR_BITS
@addr[i] = AND $is_STORE, @stage_state[3], @reg_13_value[j]	// R13
%assign i i+1
%assign j j+1
%endrep
$next_stage = AND $is_STORE, (DELAY{delayof_LATCH_WORD} @stage_state[3])
// > Set address & enable
%assign i 0
%rep NUM_ADDR_BITS
@mem_addr[i] = AND $is_LOAD, @stage_state[4], @addr[i]
%assign i i+1
%endrep
$mem_enable = PULSE (AND $is_LOAD, @stage_state[4])
// > Write to register Rr
$reg_enable = AND $is_LOAD, @stage_state[5]
@reg_addr[0:3] = AND{4} $is_LOAD, @stage_state[5], @instr[0:3]
;@reg_addr[0] = AND $is_LOAD, @stage_state[5], @instr[0]
;@reg_addr[1] = AND $is_LOAD, @stage_state[5], @instr[1]
;@reg_addr[2] = AND $is_LOAD, @stage_state[5], @instr[2]
;@reg_addr[3] = AND $is_LOAD, @stage_state[5], @instr[3]
@reg_data_in = AND{NUM_GPR_BITS} $is_LOAD, @stage_state[5], @mem_data_out
// > Reset when the write completes
$next_instruction = PULSE (AND $is_LOAD, @stage_state[6])

// --- STORE ---
// > Read register Rr
$reg_enable  = AND $is_STORE, @stage_state[2]
@reg_addr[0] = AND $is_STORE, @stage_state[2], @instr[0]
@reg_addr[1] = AND $is_STORE, @stage_state[2], @instr[1]
@reg_addr[2] = AND $is_STORE, @stage_state[2], @instr[2]
@reg_addr[3] = AND $is_STORE, @stage_state[2], @instr[3]
// > Store read value in the @val LATCH
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_STORE, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
// > Read X (R13:R12) into @addr LATCH (Takes 3 cycles to fully complete)
%assign i 0
%rep NUM_GPR_BITS
@addr[i] = AND $is_STORE, @stage_state[3], @reg_12_value[i]	// R12
%assign i i+1
%endrep
%assign j 0
%rep NUM_GPR_BITS
@addr[i] = AND $is_STORE, @stage_state[3], @reg_13_value[j]	// R13
%assign i i+1
%assign j j+1
%endrep
$next_stage = AND $is_STORE, (DELAY{delayof_LATCH_WORD} @stage_state[3])
// > Set address
%assign	i 0
%rep NUM_ADDR_BITS
@mem_addr[i] = AND $is_STORE, @stage_state[4], @addr[i]
%assign i i+1
%endrep
// > Enable, Write and Data
$mem_enable = PULSE (AND $is_STORE, @stage_state[4])
$mem_write = PULSE (AND $is_STORE, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@mem_data_out[i] = PULSE (AND $is_STORE, @stage_state[4], @val[i])
%assign i i+1
%endrep
// > Reset when the write succeeds
$next_instruction = PULSE (AND $is_STORE, @stage_state[5])


// --- MOVar ---
// > Read register Rr
@reg_addr[0] = AND $is_MOVar, (PULSE @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_MOVar, (PULSE @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_MOVar, (PULSE @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_MOVar, (PULSE @stage_state[2]), @instr[3]
// reg_addr should have reverted to zero by now (stage 2), so we just use the
// "stored" value from @reg_data_in to write to A
$reg_enable = PULSE (AND $is_MOVar, @stage_state[3])
$reg_write = PULSE (AND $is_MOVar, @stage_state[3])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = PULSE (AND $is_MOVar, @stage_state[3], @reg_data_in[i])
%assign i i+1
%endrep
// Reset when write completes
$next_instruction = PULSE (AND $is_MOVar, @stage_state[4])


// --- MOVra ---
// > Read from R0 (A)
// > Set register address again
@reg_addr[0] = AND $is_MOVra, (DELAY @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_MOVra, (DELAY @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_MOVra, (DELAY @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_MOVra, (DELAY @stage_state[2]), @instr[3]
// > Write data from R0 to Rr
$reg_enable = PULSE (AND $is_MOVar, @stage_state[2])
$reg_write = PULSE (AND $is_MOVar, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = PULSE (AND $is_MOVar, @stage_state[2], @reg_0_value[i])
%assign i i+1
%endrep
// Reset when write completes
$next_instruction = PULSE (AND $is_MOVar, @stage_state[3])

// --- ADD A, Rr ---
// > Read to @val
@reg_addr[0] = AND $is_ADD, (DELAY @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_ADD, (DELAY @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_ADD, (DELAY @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_ADD, (DELAY @stage_state[2]), @instr[3]
$reg_enable = PULSE (AND $is_ADD, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_ADD, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
// > Read A
$reg_enable = PULSE (AND $is_ADD, @stage_state[3])
// > Get A + Rr
$flags_C_clear = PULSE (AND $is_ADD, @stage_state[4])	// Clear Carry Flag
$next_stage, @add_temp, $flags_C = ADDER_ %+ NUM_GPR_BITS %+ BIT (AND $is_ADD, @stage_state[4]), @val, @reg_data_in, $flags_C
// > Write Back
$reg_write = PULSE (AND $is_ADD, @stage_state[5])
$reg_enable = PULSE (AND $is_ADD, @stage_state[5])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = DELAY (AND $is_ADD, @stage_state[5], @add_temp[i])
%assign i i+1
%endrep
$next_instruction = PULSE (AND $is_ADD, @stage_state[6])

// --- SUB A, Rr ---
// > Read to @val
;@reg_addr[0] = AND $is_ADD, (DELAY @stage_state[2]), @instr[0]
;@reg_addr[1] = AND $is_ADD, (DELAY @stage_state[2]), @instr[1]
;@reg_addr[2] = AND $is_ADD, (DELAY @stage_state[2]), @instr[2]
;@reg_addr[3] = AND $is_ADD, (DELAY @stage_state[2]), @instr[3]
@reg_addr = AND{4} $is_ADD, (DELAY @stage_state[2]), @instr[0], @instr[1], @instr[2], @instr[3]
$reg_enable = PULSE (AND $is_ADD, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_ADD, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
// > Read A
$reg_enable = PULSE (AND $is_ADD, @stage_state[3])
// > Get A + Rr
$flags_C_clear = PULSE (AND $is_ADD, @stage_state[4])	// Clear Carry Flag
$next_stage, @add_temp, $flags_C = SUBTRACTOR_ %+ NUM_GPR_BITS %+ BIT (AND $is_ADD, @stage_state[4]), @val, @reg_data_in, $flags_C
// > Write Back
$reg_write = PULSE (AND $is_ADD, @stage_state[5])
$reg_enable = PULSE (AND $is_ADD, @stage_state[5])
@reg_data_out = DELAY (AND{NUM_GPR_BITS} $is_ADD, @stage_state[5], @add_temp)
$next_instruction = PULSE (AND $is_ADD, @stage_state[6])

// --- AND A, Rr ---
// > Read to @val
@reg_addr[0] = AND $is_AND, (DELAY @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_AND, (DELAY @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_AND, (DELAY @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_AND, (DELAY @stage_state[2]), @instr[3]
$reg_enable = PULSE (AND $is_AND, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_AND, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
// > Read A
$reg_enable = PULSE (AND $is_AND, @stage_state[3])
// > Write back A & Rr
$reg_write = PULSE (AND $is_AND, @stage_state[4])
$reg_enable = PULSE (AND $is_AND, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = DELAY (AND $is_AND, @stage_state[4], @val[i], @reg_data_in[i])
%assign i i+1
%endrep
$next_instruction = PULSE (AND $is_AND, @stage_state[5])

// --- OR A, Rr ---
// > Read to @val
@reg_addr[0] = AND $is_OR, (DELAY @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_OR, (DELAY @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_OR, (DELAY @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_OR, (DELAY @stage_state[2]), @instr[3]
$reg_enable = PULSE (AND $is_OR, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_OR, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
// > Read A
$reg_enable = PULSE (AND $is_OR, @stage_state[3])
// > Write back A | Rr
$reg_write = PULSE (AND $is_OR, @stage_state[4])
$reg_enable = PULSE (AND $is_OR, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = AND (AND $is_OR, @stage_state[4]), (OR @val[i], @reg_data_in[i])
%assign i i+1
%endrep
$next_instruction = PULSE (AND $is_OR, @stage_state[5])

// --- XOR A, Rr ---
#display $is_XOR "XOR A, Rr" @instr[3], @instr[2], @instr[1], @instr[0]
// > Read to @val
@reg_addr[0] = AND $is_XOR, (DELAY @stage_state[2]), @instr[0]
@reg_addr[1] = AND $is_XOR, (DELAY @stage_state[2]), @instr[1]
@reg_addr[2] = AND $is_XOR, (DELAY @stage_state[2]), @instr[2]
@reg_addr[3] = AND $is_XOR, (DELAY @stage_state[2]), @instr[3]
$reg_enable = PULSE (AND $is_XOR, @stage_state[2])
%assign	i 0
%rep NUM_GPR_BITS
@val[i] = AND $is_XOR, @stage_state[3], @reg_data_in[i]
%assign i i+1
%endrep
#display (AND $is_XOR, @stage_state[3]) "val  " @reg_data_in
// > Read A
$reg_enable = PULSE (AND $is_XOR, @stage_state[3])
// > Write back A ^ Rr
$reg_write = PULSE (AND $is_XOR, @stage_state[4])
$reg_enable = PULSE (AND $is_XOR, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = AND (AND $is_XOR, @stage_state[4]), (XOR @val[i], @reg_data_in[i])
%assign i i+1
%endrep
#display (AND $is_XOR, @stage_state[4]) "A    " @reg_data_out
#display (AND $is_XOR, @stage_state[4]) "res  " @reg_data_out
$next_instruction = PULSE (AND $is_XOR, @stage_state[5])

// --- SHL A, Rr ---
// TODO:

// --- PUSH A ---
// TODO: Implement

// --- POP A ---
// TODO: Implement

// --- NOT A ---
#display $is_NOT_A "NOT A" $is_NOT_A
// > Read A
$reg_enable = PULSE (AND $is_NOT_A, @stage_state[2])
#display (AND $is_NOT_A, @stage_state[3]) "A  " @reg_data_in
// > Write back, changed
$reg_write = PULSE (AND $is_NOT_A, @stage_state[3])
$reg_enable = PULSE (AND $is_NOT_A, @stage_state[3])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = AND (AND $is_NOT_A, @stage_state[3]), (NOT @reg_data_in[i])
%assign i i+1
%endrep
#display (AND $is_NOT_A, @stage_state[4]) "A    " @reg_data_out
#display (AND $is_NOT_A, @stage_state[4]) "res  " @reg_data_out
$next_instruction = PULSE (AND $is_NOT_A, @stage_state[5])

// --- NEG A ---
// TODO:
#display $is_NEG_A "NEG A" $is_NEG_A
#display $is_NEG_A "TODO: NEG A" $is_NEG_A

// --- CLC ---
$flags_C_clear = AND $is_CLC, @stage_state[2]
$next_instruction = PULSE (AND $is_CLC, @stage_state[2])

// --- STC ---
$flags_C = AND $is_SRC, @stage_state[2]
$next_instruction = PULSE (AND $is_CLC, @stage_state[2])

// --- LDI ---
// Load Data Immediate
// A := imm8
// - Wait until PC is valid
$next_stage = AND $is_LDI_A, $reg_pc_valid
// - Read value from memory
%assign i 0
%rep NUM_ADDR_BITS
@mem_addr[i] = DELAY (AND $is_LDI_A, @stage_state[3], @reg_pc_in[i])
%assign i i+1
%endrep
$mem_enable = PULSE (AND $is_LDI_A, @stage_state[3])	// Enable memory for read
$increment_pc = PULSE (AND $is_LDI_A, @stage_state[3])	// Increment PC
// - Save to A
$reg_write = PULSE (AND $is_LDI_A, @stage_state[4])
$reg_enable = PULSE (AND $is_LDI_A, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@reg_data_out[i] = DELAY (AND $is_LDI_A, @stage_state[4], @mem_data_in[i])
%assign i i+1
%endrep
// - Next Instruction
$next_instruction = PULSE (AND $is_LDI_A, @stage_state[5])

// --- LAI ---
// Load Address Immediate
// X := imm16
// - Wait until PC is valid
$next_stage = AND $is_LAI_A, $reg_pc_valid
// - Read low byte of address
%assign i 0
%rep NUM_ADDR_BITS
@mem_addr[i] = DELAY (AND $is_LAI_A, @stage_state[3], @reg_pc_in[i])
%assign i i+1
%endrep
$mem_enable = PULSE (AND $is_LAI_A, @stage_state[3])	// Enable memory for read
$increment_pc = PULSE (AND $is_LAI_A, @stage_state[3])	// Increment PC
// - Save to R12
$reg_12_write = PULSE (AND $is_LAI_A, @stage_state[4])
%assign	i 0
%rep NUM_GPR_BITS
@reg_12_newvalue[i] = DELAY (AND $is_LAI_A, @stage_state[4], @mem_data_in[i])
%assign i i+1
%endrep
$next_stage = PULSE (AND $is_LAI_A, (DELAY{2} @stage_state[4]))
// - Read high byte of address
%assign i 0
%rep NUM_ADDR_BITS
@mem_addr[i] = DELAY (AND $is_LAI_A, @stage_state[5], @reg_pc_in[i])
%assign i i+1
%endrep
$mem_enable = PULSE (AND $is_LAI_A, @stage_state[5])	// Enable memory for read
$increment_pc = PULSE (AND $is_LAI_A, @stage_state[5])	// Increment PC
// - Save to R13
$reg_13_write = PULSE (AND $is_LAI_A, @stage_state[6])
%assign	i 0
%rep NUM_GPR_BITS
@reg_13_newvalue[i] = DELAY (AND $is_LAI_A, @stage_state[6], @mem_data_in[i])
%assign i i+1
%endrep
// - Next Instruction
$next_instruction = PULSE (AND $is_LAI_A, @stage_state[6])
