;
; Adders
;
%ifndef _ADDER_CCT
%define _ADDER_CCT

;
; 1-bit full adder
;
#defunit ADDER
#input $val1, $val2, $carry_in
#output $ret, $carry_out

$ret       = DELAY (XOR $val1, $val2, $carry_in)
$carry_out = OR (AND $val1, $val2), (AND $val1, $carry_in), (AND $val2, $carry_in)

#endunit

#testcase 4 "Full Adder"
$en = PULSE 1
$ret, $carry = ADDER $en, $en, $en
#testassert (DELAY{2} $en) $ret 1
#testassert (DELAY{2} $en) $carry 1
#testcomplete (DELAY{2} $en)
#endtestcase

;
; 4-bit Carry-Bypass adder
;
#defunit ADDER_4BYPASS
#input $carry_in, @val1[4], @val2[4]
#output $carry_out, @ret[4]

#array p 4	// Propogate
#array g 4	// Generate
#array c 4	// Carry Out

@p = XOR{4,2} @val1, @val2	// 2x 4-bit busses
@g = AND{4,2} @val1, @val2	// 2x 4-bit busses

@c   = DELAY @g
@c   = AND{4,2} @p, $carry_in, @c[0:2]	// (@p[0], @p[1], @p[2], @p[3]) AND ($carry_in, @c[0], @c[1], @c[2])
@ret = XOR{4,2} @p, $carry_in, @c[0:2]

$bypass = AND @p
$carry_out = MUX{1} $bypass, $carry_in, $_carry	// 1-bit MUX
$carry_out = AND @p, $carry_in

#endunit

;
; 4-Bit Ripple-Carry Adder
; Delay of 9 (4*ADDER + 3)
;
#defunit ADDER_4BIT_RIPPLE
#input $enable, @val1[4], @val2[4], $carry_in
#output $ready, @ret[4], $carry_out
#array _ret 4
#array carry 4

@_ret[0], @carry[0] = ADDER @val1[0], @val2[0], $carry_in
@_ret[1], @carry[1] = ADDER (DELAY{2} @val1[1], @val2[1]), @carry[0]
@_ret[2], @carry[2] = ADDER (DELAY{4} @val1[2], @val2[2]), @carry[1]
@_ret[3], @carry[3] = ADDER (DELAY{6} @val1[3], @val2[3]), @carry[2]

@ret[0] = AND (DELAY{8} $enable), (DELAY{6} @_ret[0])
@ret[1] = AND (DELAY{8} $enable), (DELAY{4} @_ret[1])
@ret[2] = AND (DELAY{8} $enable), (DELAY{2} @_ret[2])
@ret[3] = AND (DELAY{8} $enable), @_ret[3]

$carry_out = AND (DELAY{8} $enable), @carry[3]
$ready = DELAY{9} $enable

#endunit

; NOTE: Test should take ADDER_4BIT_RIPPLE + 2 = 11
#testcase 12 "Adder 4 Ripple - 15+15+1"
#array ret 4
$en = PULSE 1
$done, @ret, $carry = ADDER_4BIT_RIPPLE (DELAY $en), (AND{4+4+1} $en, 15[0:3], 15[0:3], 1)
#testassert $done @ret[3:0] 15[3:0]
#testassert $done $carry 1
#testcomplete $done
#endtestcase

#testcase 12 "Adder 4 Ripple - 10+4+0"
#array ret 4
$en = PULSE 1
$done, @ret, $carry = ADDER_4BIT_RIPPLE (DELAY $en), (AND{4+4+1} $en, 10[0:3], 4[0:3], 0)
#testassert $done @ret[3:0] 14[3:0]
#testassert $done $carry 0
#testcomplete $done
#endtestcase

;
; One bit carry-lookahead adder
;
#defunit ADDER_CL
#input $a, $b, $c	; A, B, Carry In
#output $s, $p, $g	; Sum, Propogate, Generate

$s = XOR $a, $b, $c
$p = XOR $a, $b
// Generate hacked up using OR nature of assign (to have delay be 1)
$g = AND $a, $b
$g = AND $a, $c
$g = AND $b, $c

#endunit

// 4-Bit Carry-Lookahead Adder
// Delay of ??
// NOTE: Incomplete
#defunit ADDER_4BIT_CL
#input $enable, @val1[4], @val2[4], $carry_in
#output $ready, @ret[4], $carry_out
#array _ret 4
#array _p 4
#array _g 4
#array carry 4

@_ret[0], @_p[0], @_g[0] = ADDER_CL @val1[0], @val1[0], $carry_in

#endunit

// 8-Bit Carry-Select Adder
// - Delay of 13 (ADDER_4BIT_RIPPLE + 2)
#defunit ADDER_8BIT
#input $enable, @val1[8], @val2[8], $carry_in
#output $ready, @ret[8], $carry_out
#array _ret_low 4
#array _ret_hi_0 4
#array _ret_hi_1 4

$ready_first, @_ret_low, $carry_mid = ADDER_4BIT_RIPPLE $enable, @val1[0:3], @val2[0:3], $carry_in
$NULL, @_ret_hi_0, $carry_0 = ADDER_4BIT_RIPPLE $enable, @val1[4:7], @val2[4:7], 0
$NULL, @_ret_hi_1, $carry_1 = ADDER_4BIT_RIPPLE $enable, @val1[4:7], @val2[4:7], 1
@ret[0:3]  = AND{4} (DELAY $ready_first), (DELAY @_ret_low)
@ret[4:7]  = AND{4} (DELAY $ready_first), (MUX{1,4} $carry_mid, @_ret_hi_0, @_ret_hi_1)
$carry_out = AND (DELAY $ready_first), (MUX $carry_mid, $carry_0, $carry_1)
$ready = DELAY{2} $ready_first

#endunit

// 16-Bit Adder
// - Delay of 15 (ADDER_8BIT + 2)
#defunit ADDER_16BIT
#input $enable, @val1[16], @val2[16], $carry_in
#output $ready, @ret[16], $carry_out
#array _ret_low 8
#array _ret_hi_0 8
#array _ret_hi_1 8

$ready_first, @_ret_low, $carry_mid = ADDER_8BIT $enable, @val1[0:7], @val2[0:7], $carry_in
$NULL, @_ret_hi_0, $carry_0 = ADDER_8BIT $enable, @val1[8:15], @val2[8:15], 0
$NULL, @_ret_hi_1, $carry_1 = ADDER_8BIT $enable, @val1[8:15], @val2[8:15], 1
@ret[0:7]  = AND{8} (DELAY $ready_first), (DELAY @_ret_low)
@ret[8:15] = AND{8} (DELAY $ready_first), (MUX{1,8} $carry_mid, @_ret_hi_0, @_ret_hi_1)
$carry_out = AND (DELAY $ready_first), (MUX $carry_mid, $carry_0, $carry_1)
$ready = DELAY{2} $ready_first

#endunit

// 32-Bit Adder
// - Delay of 17 (ADDER_16BIT + 2)
%define bits	32
#defunit ADDER_32BIT
#input $enable, @val1[bits], @val2[bits], $carry_in
#output $ready, @ret[bits], $carry_out
#array _ret_low bits/2
#array _ret_hi_0 bits/2
#array _ret_hi_1 bits/2

$ready_first, @_ret_low, $carry_mid = ADDER_16BIT $enable, @val1[0:bits/2-1], @val2[0:bits/2-1], $carry_in
$NULL, @_ret_hi_0, $carry_0 = ADDER_16BIT $enable, @val1[bits/2:bits-1], @val2[bits/2:bits-1], 0
$NULL, @_ret_hi_1, $carry_1 = ADDER_16BIT $enable, @val1[bits/2:bits-1], @val2[bits/2:bits-1], 1
@ret[0:bits/2-1]  = AND{bits/2} (DELAY $ready_first), (DELAY @_ret_low)
@ret[bits/2:bits-1] = AND{bits/2} (DELAY $ready_first), (MUX{1,bits/2} $carry_mid, @_ret_hi_0, @_ret_hi_1)
$carry_out = AND (DELAY $ready_first), (MUX $carry_mid, $carry_0, $carry_1)
$ready = DELAY{2} $ready_first

#endunit


#testcase 20 "Adder CS 32"
#array ret 32
$done, @ret, $carry = ADDER_32BIT 1, 0x12345678[0:31], 0xF0EDCBA0[0:31], 1
#testassert $done @ret[31:0] 0x03222219[31:0]	// (0x12345678 + 0xF0EDCBA0 + 1) % 2**32
#testassert $done $carry 1
#testcomplete $done
#endtestcase

%endif

; vim: ft=logiccircuit
