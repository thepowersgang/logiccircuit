;
; CPU-32 Design
; - By John Hodge (thePowersGang)
;
; address_decode.cct
; - Decodes and reads values for general operations
;
; === USAGE ===
; INPUT
; - $trigger : Pulse used to control start decoding
; - $read_r  : Decode and read the 'R' operand (bits 23:20)
; - $read_m  : Decode and read the 'm' operand (immediate/register/memory)
; - @instr   : Instruction data (full 32 bits)
; OUTPUT
; - $rdy     : Raised when the operation is completed
; - $is_mem_dest : Set if the destination is a memory address (as opposed to a register num)
; - @dest_addr : Destination address / register number (register num is stored in low 4 bits)
; - @op_1    : First operand (usually R, unless $is_mem_dest is set)
; - @op_2    : First operand (usually m, unless $is_mem_dest is set)
; IMPORTS? (TODO: Are imports possible?)
; - $reg_enable   : Enable register unit
; - @reg_addr[4]  : Register read select (3 unit lag)
; - @reg_data_in[32] : Register data
; - $mem_enable   : Memory enable line (performs read at @mem_addr)
; - $mem_ready    : Set when the memory data is ready
; - @mem_addr[32] : Memory address
#defunit CPU32_ADDRESS_DECODE
#input $trigger, $in_rdy_clear, $read_r, $read_m, @instr[32], \
	$reg_enable, @reg_addr[4], $reg_ready, @reg_data_in[32], \
	$mem_enable, @mem_addr[32], $mem_ready, @mem_data_in[32]
#output $rdy, $is_mem_dest, @dest_addr[32], @op_1[32], @op_2[32]

$_pulse = PULSE $trigger
$op_clear = PULSE $trigger
$rdy_clear = PULSE $trigger
$rdy_clear = PULSE $in_rdy_clear
$int_addr_clear = PULSE $trigger

$pulse = PULSE $_enable

#display $pulse "$pulse = %1i, $_enable = %1i" $pulse, $_enable
#display $rdy_clear "$rdy_clear = %1i" $rdy_clear

$NULL, $_enable = LATCH 1, $rdy_clear, (DELAY $trigger)
$NULL, @dest_addr = LATCH{32} 1, $_pulse, @dest_addr
$NULL, @op_1 = LATCH{32} 1, $op_clear, @op_1
$NULL, @op_2 = LATCH{32} 1, $op_clear, @op_2
$NULL, $rdy = LATCH{1} 1, $rdy_clear, $rdy
$NULL, $op_2_read = LATCH{1} 1, $_pulse, $op_2_read_set
$op_1_read = DELAY $op_1_read	// Reduces latency when starting

#display (AND $trigger, $read_r) "op_1" @op_1[31:0]
#display (AND $trigger, $read_m) "op_2" @op_2[31:0]
#display $is_mem_dest "Memory Destination" 0
#display $trigger "mode" @instr[26:24]
#display $trigger "R" @instr[23:20]
#display $trigger "m" @instr[19:16]

#array int_addr 32
$NULL, @int_addr = LATCH{32} 1, $int_addr_clear, @int_addr
#display $trigger "internal addr = 0x%32x" @int_addr[31:0]

; Decode
$is_op_Rr   = AND $_enable, (NOT   @instr[26]), (NOT   @instr[25]), (NOT   @instr[24])
$is_op_Ri20 = AND $_enable, (NOT   @instr[26]), (NOT   @instr[25]), (DELAY @instr[24])
$is_op_Ri16 = AND $_enable, (NOT   @instr[26]), (DELAY @instr[25]), (NOT   @instr[24])
$is_op_Rs16 = AND $_enable, (NOT   @instr[26]), (DELAY @instr[25]), (DELAY @instr[24])
$is_op_RM16 = AND $_enable, (DELAY @instr[26]), (NOT   @instr[25]), (NOT   @instr[24])
$is_op_RM8  = AND $_enable, (DELAY @instr[26]), (NOT   @instr[25]), (DELAY @instr[24])
$is_op_M16R = AND $_enable, (DELAY @instr[26]), (DELAY @instr[25]), (NOT   @instr[24])
$is_op_M8R  = AND $_enable, (DELAY @instr[26]), (DELAY @instr[25]), (DELAY @instr[24])

$is_mem_dest = OR $is_op_M8R, $is_op_M16R
@dest_addr[3:0] = AND{4} (DELAY{3} $pulse), (NOT $is_mem_dest), @instr[23:20]

; Rr
$reading_Rr = AND $pulse, $read_m, $is_op_Rr
$op_2_read_set = AND $read_m, $is_op_Rr, $reg_ready
$reg_enable = DELAY $reading_Rr
@reg_addr[3:0] = AND{4} $reading_Rr, @instr[19:16]
@op_2 = AND{32} $read_m, $is_op_Rr, (NOT $reading_op1), $reg_ready, @reg_data_in

; Ri20
$reading_Ri20 = AND $pulse, $read_m, $is_op_Ri20
$op_2_read_set = DELAY $reading_Ri20
@op_2[19:0] = AND{20} $reading_Ri20, @instr[19:0]

; Ri16 / Rs16
; - This uses that 4 bits of rotate on a 16-bit value can't wrap in a 32-bit container
$reading_Ri16 = AND $pulse, $read_m, $is_op_Ri16
$reading_Ri16 = AND $pulse, $read_m, $is_op_Rs16
$_Ri16_sign = AND $is_op_Rs16, @instr[15]
$op_2_read_set, @op_2[0:31] = ROTATE_LEFT_N_32 $reading_Ri16, @instr[16:19],0, @instr[0:15],$_Ri16_sign*16

#array _mem_add_op1 32
#array _mem_add_op2 32
#array _mem8_reg_shifted 32

; === RM16 / M16R ===
$is_M16 = OR $is_op_RM16, $is_op_M16R
$reading_M16 = AND $pulse, $read_m, $is_op_RM16
$reading_M16 = AND $pulse, $read_m, $is_op_M16R
; - Prepare add
$reg_enable = DELAY $reading_M16
@reg_addr[3:0] = AND{4} $reading_M16, @instr[19:16]
$m16_add_ready = AND $_enable, $is_M16, $reg_ready, (NOT $reading_op1)
@_mem_add_op1 = AND{32} $m16_add_ready, (DELAY @reg_data_in)
@_mem_add_op2[31:0] = AND{32} $m16_add_ready, \
	@instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], \
	@instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], @instr[15], \
	@instr[15:0]
$_mem_add_start = DELAY $m16_add_ready
; - Add is done, trigger the read
$addr_ready = AND $_enable, $is_M16, $_mem_add_done
; === RM8 / M8R ===
$is_M8 = OR $is_op_RM8, $is_op_M8R
$reading_M8 = AND $pulse, $read_m, $is_op_RM8
$reading_M8 = AND $pulse, $read_m, $is_op_M8R
$is_M8_stg1_clear = OR $_pulse, $_mem8_add1_done
$NULL, $is_M8_stg1 = LATCH 1, $is_M8_stg1_clear, (PULSE $is_M8)
$is_M8_stg2_clear = OR $_pulse, $_mem8_shift_done
$NULL, $is_M8_stg2 = LATCH 1, $is_M8_stg2_clear, $_mem8_add1_done
; - Stage 1: add Base + Offset
$reg_enable = DELAY $reading_M8
@reg_addr[3:0] = AND{4} $reading_M8, @instr[19:16]
@_mem_add_op1 = AND{32} (DELAY{3} $reading_M8), @reg_data_in
@_mem_add_op2[31:0] = AND{32} (DELAY{3} $reading_M8), \
	@instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], \
	@instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], \
	@instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], @instr[7], \
	@instr[7:0]
$_mem_add_start = DELAY{4} $reading_M8
$_mem8_add1_done = AND $is_M8, $is_M8_stg1, $_mem_add_done
; - Stage 2: rotate index
$reg_enable = PULSE $is_M8_stg2
@reg_addr[3:0] = AND{4} $is_M8_stg2, @instr[15:12]
$_mem8_shift_trigger = AND $reg_ready, $is_M8_stg2, $is_M8
#display $_mem8_shift_trigger "mem8_shift input" (DELAY @reg_data_in)
$_mem8_shift_done, @_mem8_reg_shifted, $NULL = SHIFT_LEFT_N_32 $_mem8_shift_trigger,\
	@instr[8:11],0, (DELAY @reg_data_in), \
	0
#display $_mem8_shift_done "@_mem8_reg_shifted = %32x" @_mem8_reg_shifted[31:0]
; - Stage 3: add above two
@_mem_add_op1 = AND{32} $_mem8_shift_done, @_mem8_reg_shifted
@_mem_add_op2 = AND{32} $_mem8_shift_done, @int_addr
$_mem_add_start = PULSE $_mem8_shift_done
$int_addr_clear = PULSE $_mem8_shift_done
$addr_ready = AND $is_M8, (NOT $is_M8_stg1), $_mem_add_done
; === Common Adder for Memory ===
#display $_mem_add_start "add 0x%32x and 0x%32x" @_mem_add_op1[31:0], @_mem_add_op2[31:0]
$_mem_add_done, @int_addr, $NULL = ADDER_32BIT $_mem_add_start, @_mem_add_op1, @_mem_add_op2, 0
#display $_mem_add_done "add gave 0x%32x" @int_addr[31:0]

; === Memory Load ===
@dest_addr = AND{32} $addr_ready, $is_mem_dest, @int_addr
$mem_enable = DELAY $addr_ready
@mem_addr = AND{32} $addr_ready, @int_addr
@op_2 = AND{32} $is_M8, $mem_ready, @mem_data_in
@op_2 = AND{32} $is_M16, $mem_ready, @mem_data_in
$op_2_read_set = PULSE $mem_ready
//#display $op_2_read_set "op_2 value" @op_2

; === Skip Op2? ===
$op_2_read_set = AND $pulse, (NOT $read_m)

; === Read Op1 ===
$reading_op1 = AND $read_r, $op_2_read
#display $reading_op1 "Reading OP1" 0
$reg_enable = PULSE $reading_op1
@reg_addr[3:0] = AND{4} $reading_op1, @instr[23:20]
@op_1 = AND{32} $reading_op1, $reg_ready, @reg_data_in
$op_1_read = AND $reading_op1, $reg_ready
; === Skip Op1? ===
$op_1_read = AND $op_2_read, (NOT $read_r)

; === Ready if not mem dest ===
$rdy = AND $op_1_read, (NOT $is_mem_dest)
; === Swap if mem dest ===
$_swap_ops = AND (PULSE $op_1_read), $is_mem_dest
#display $_swap_ops "Swapping OP1/OP2 %32x and %32x" @op_1[31:0], @op_2[31:0]
@op_1 = DELAY{3} (AND{32} $_swap_ops, @op_2)
@op_2 = DELAY{3} (AND{32} $_swap_ops, @op_1)
$op_clear = DELAY $_swap_ops
$rdy = DELAY{3+2} $_swap_ops

#endunit

; vim: ft=logiccircuit
