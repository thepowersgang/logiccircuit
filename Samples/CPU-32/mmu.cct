//
// 32-bit CPU
// By John Hodge (thePowersGang)
// Designed in LogicCircuit
// 
// mmu.cct
// - Memory Management Unit (Paging)

%define MMU_PERMBITS	1
%define MMU_PHYSBITS	20

//
// Translation Lookaside Buffer
// 
#defunit CPU32_MMU_TLB
#input $enable, @vpage[20], $set, @ppage_in[MMU_PHYSBITS],@perms_in[MMU_PERMBITS]
#output $ready, $hit, @ppage_out[MMU_PHYSBITS],@perms[MMU_PERMBITS]

#display $enable "vpage=%20x, set=%1i, ppage_in=%20x" @vpage[19:0], $set, @ppage_in[19:0]

%define TLBBITS 1+20+MMU_PHYSBITS+MMU_PERMBITS
%define TLBSLOTS	16

%macro tlbslot 1
#array tlbent_ %+ %1 TLBBITS
#array tlbent_set_ %+ %1 TLBBITS
@tlbent_set_ %+ %1 = AND{TLBBITS} @clr[%1], (DELAY{3} @vpage,@ppage_in,@perms_in,1)
$NULL, @tlbent_ %+ %1 = LATCH{TLBBITS} 1, @clr[%1], @tlbent_set_ %+ %1
$hit_ %+ %1 = AND @tlbent_ %+ %1[TLBBITS-1], (XNOR{20,2} @vpage[0:19], @tlbent_ %+ %1[0:19])
$enabled_hit_ %+ %1 = AND (DELAY{2} $enable),$hit_ %+ %1
$hit,@ppage_out,@perms = ENABLE $enabled_hit_ %+ %1, 1,@tlbent_ %+ %1[20:20+MMU_PHYSBITS+MMU_PERMBITS-1]
%endmacro

#array clr TLBSLOTS
%assign i 0
%rep TLBSLOTS
tlbslot i
%assign i i+1
%endrep

#display 1 "TLB[0] = %1i %20x %20x (%1i)" @tlbent_0[40:0], $hit_0
#display 1 "TLB[1] = %1i %20x %20x (%1i)" @tlbent_1[40:0], $hit_1
#display 1 "TLB[2] = %1i %20x %20x (%1i)" @tlbent_2[40:0], $hit_2
#display 1 "TLB[3] = %1i %20x %20x (%1i)" @tlbent_3[40:0], $hit_3

$ready = DELAY{4} $enable

#array next_write_tlb	TLBSLOTS
@next_write_tlb = SEQUENCER{TLBSLOTS} 1, 0, (PULSE $set)
#display 1 "TLB Next  = %16b" @next_write_tlb
#display 1 "TLB Clear = %16b" @clr

@clr = AND{TLBSLOTS} (DELAY{2} $set,$enable), @next_write_tlb
#endunit

//
// Permissions checking
//
#defunit CPU32_MMU_CHECKBITS
#input $enable,@lowbits[12]
#output $done,$fail,@whyfail[12]

$NULL = OR @lowbits[1:11]
@whyfail[1:11] = DELAY 0[1:11]

$delay_enable = DELAY $enable

@whyfail[0] = NOT @lowbits[0]	; If ent.0 != 1, fail due to NP
$fail = AND $delay_enable, (OR @whyfail)
$done = PULSE $delay_enable

#endunit


//
// MMU Page-waking unit
//
#defunit CPU32_MMU_PAGEWALK
#input $enable,@mmu_base[32], @addr[20], $pmem_ready,@pmem_data[32]
#output $ready,@addr_out[MMU_PHYSBITS],@perms_out[MMU_PERMBITS],\
	   $fault,@fault_reason[12], $pmem_enable,@pmem_addr[32]

#display $enable "Base = %32x, VAddr=%20x" @mmu_base[31:0], @addr[19:0]

// Raise reset on the falling edge of $enable
$reset = PULSE{1} $enable

// Result latches
#array addr_set	MMU_PHYSBITS
#array perms_set	MMU_PERMBITS
$NULL, @addr_out,@perms_out = LATCH{MMU_PHYSBITS+MMU_PERMBITS} 1, $reset, @addr_set,@perms_set
$NULL, $ready = LATCH{1} 1, $reset, $ready_set
#array reason_set	12
$NULL, @fault_reason = LATCH{12} 1, $reset, @reason_set
$NULL, $fault = LATCH{1} 1, $reset, $fault_set

// Internal latches
// - TODO: Could kill one of these if needed
#array lvl1_set	32
#array lvl1	32
$NULL, @lvl1 = LATCH{32} 1, $reset, @lvl1_set
#array lvl2_set	32
#array lvl2	32
$NULL, @lvl2 = LATCH{32} 1, $reset, @lvl2_set

// Raise ready when a fault is asserted
$ready_set = PULSE $fault

#array stage	8
@stage = SEQUENCER{8} 1, $reset, $next_stage
#display $enable "MMU Stage" @stage

// [0]: Idle
$next_stage = AND @stage[0], (PULSE $enable)
// [1]: Request Lvl1
$pmem_enable,@pmem_addr[31:0] = ENABLE @stage[1], 1,@mmu_base[31:12],@addr[19:10],0,0
$lvl1_ready,@lvl1_set         = ENABLE @stage[1], $pmem_ready,@pmem_data
$next_stage = PULSE $lvl1_ready
// [2]: Check permissions on Lvl1 entry
#array lvl1_fail_rsn	12
$lvl1_check_done,$lvl1_check_fail,@lvl1_fail_rsn = CPU32_MMU_CHECKBITS @stage[2], @lvl1[0:11]
$next_stage   = PULSE (AND (DELAY $lvl1_check_done), (NOT $lvl1_check_fail))
$fault_set  = ENABLE $lvl1_check_done, $lvl1_check_fail
@reason_set = ENABLE $lvl1_check_done, @lvl1_fail_rsn
// [3]: Request Lvl2
$pmem_enable,@pmem_addr[31:0] = ENABLE @stage[3], 1,@lvl1[31:12],@addr[9:0],0,0
$lvl2_ready,@lvl2_set         = ENABLE @stage[3], $pmem_ready,@pmem_data
$next_stage = PULSE $lvl2_ready
// [4]: Check permissions on lvl2 entry
#array lvl2_fail_rsn	12
$lvl2_check_done,$lvl2_check_fail,@lvl2_fail_rsn = CPU32_MMU_CHECKBITS @stage[4], @lvl2[0:11]
$next_stage   = PULSE (AND (DELAY $lvl2_check_done), (NOT $lvl2_check_fail))
$fault_set  = ENABLE $lvl2_check_done, $lvl2_check_fail
@reason_set = ENABLE $lvl2_check_done, @lvl2_fail_rsn
// [5]: Set address
@addr_set[19:0] = ENABLE @stage[5], @lvl2[31:12]
@perms_set[0]   = ENABLE @stage[5], @lvl2[1]
$next_stage = PULSE @stage[5]
// [6]: Raise ready
$ready_set = PULSE @stage[6]

#endunit

// 
// MMU Core
//

#defunit CPU32_MMU
;#input $enable_translation,@mmu_base[32], $mem_enable,@mem_addr[32],$mem_write,@mem_data_wr[32],\
;	$pmem_ready,@pmem_data[32]
;#output $mem_ready,@mem_data[32], $pmem_enable,@pmem_addr[32],$pmem_write,@pmem_data_wr[32], \
;	$mmu_fault,@mmu_fault_data[32]

;$tlb_done,$tlb_yes,@addr_set[31:12] = CPU32_MMU_TLB $tlb_enable, @addr[31:12], $tlb_store,@addr_out[31:12]
// [1]: TLB Check
;$tlb_enable = PULSE @stage[1]
;$_tlb_fail = AND @stage[1], (DELAY $tlb_done), (NOT $tlb_yes)
;$_tlb_succ = AND @stage[1], $tlb_done, $tlb_yes
;$next_stage = PULSE $_tlb_fail
;$ready_set = PULSE $_tlb_succ

// Passthrough if $enable_translation is low


#endunit

%include "mmu_test.cct"

// vim: ft=logiccircuit
