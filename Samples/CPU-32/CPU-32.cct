// 32-bit CPU
// By John Hodge (thePowersGang)
// Designed in LogicCircuit
%include "memory.cct"
%include "../adder.cct"
%include "../subber.cct"
%include "../shift_register.cct"
%include "address_decode.cct"
%include "alu.cct"
%include "registers.cct"
%include "common.h.cct"

%define NUM_FLAGS	3

#defunit CPU32_CORE
#input $reset, $mem_ready, @mem_data_in[NUM_GPR_BITS], \
	$reg_ready, @reg_data_in[NUM_GPR_BITS], \
	@flags[NUM_FLAGS]
#output $ins_complete, $mem_enable, @mem_addr[NUM_ADDR_BITS], $mem_write, @mem_data_out[NUM_GPR_BITS], \
	$reg_enable, @reg_addr[4], $reg_write, @reg_data_out[NUM_GPR_BITS], \
	@flags_clear[NUM_FLAGS]

#array stage_num	4
#array stage_state	16

#array instr	32

#breakpoint $ins_complete "Next Instruction"
;#breakpoint $next_stage "Next Stage"
;#breakpoint $reg_pc_write "PC Write"
;#breakpoint $stage_reset "Stage Reset"

#display 1 "Stage %4x" @stage_num[3:0], @stage_state
#display 1 "Reset  " $stage_reset
#display 1 "NextS  " $next_stage
#display 1 "instr = 0x%32x" @instr[31:0]
#display 1 "NextI  " $next_instruction

$flags_C = @flags[0]
$flags_C_clear = @flags_clear[0]
$flags_O = @flags[1]
$flags_O_clear = @flags_clear[1]
$flags_Z = @flags[2]
$flags_Z_clear = @flags_clear[2]


// --- Program Counter ---
#array pc	32
#array pc_new	32
#display $pc_clear "PC CLEAR" 0
#display 1 "PC = %32x" @pc[31:0]
$pc_clear = PULSE $reset
$NULL, @pc = LATCH{32} 1, $pc_clear, @pc_new

// === "Temporary" Latches ===
// @instr - Temporary "variables" used to hold intermediate values
// to be moved to other locations
#display 1 "instr_clear=%1i" $instr_clear
$NULL, @instr = LATCH{32} 1, $instr_clear, @instr
$instr_clear = PULSE @stage_state[0]	// Clear the instruction register

// === Timing control (stages) ===
// 4-bit counter reset by $stage_reset, incremented by $next_stage
// Attached to a 4-bit de-muxer controlling the state of stages
@stage_num = COUNTER{4} $stage_reset, $next_stage
@stage_state = DEMUX{4} 1, @stage_num

// === Next instruction ===
$ins_complete = DELAY{2} (PULSE $next_instruction)
$stage_reset = PULSE $next_instruction
$stage_reset = DELAY $reset

// =============================
// === Stage 0: Opcode Fetch ===
// =============================
#display @stage_state[0] "Opcode fetch" 1
// - Request memory
@mem_addr    = AND{NUM_ADDR_BITS} @stage_state[0], @pc	// Set memory address to PC
$mem_enable  = PULSE @stage_state[0]	// Enable memory for read
// - Read complete, save into @instr
@instr = AND{32} @stage_state[0], $mem_ready, @mem_data_in	// Save the opcode
$_next_stage_OPRDY = AND @stage_state[0], $mem_ready	// Wait for instruction to be fetched
#display $_next_stage_OPRDY "next_stage (OPRDY)" 0 
$next_stage = PULSE $_next_stage_OPRDY

// =============================
// === Stage 1: Increment PC ===
// =============================
#display @stage_state[1] "PC Update" 1
// - Add 4 to PC
#array _pc_new 32
#array pc_inc_value 32	// value to increment to
#display @stage_state[1] "PC Inc Value = %32x" @pc_inc_value[31:0]
$increment_pc = PULSE @stage_state[1]	// Increment the program counter too
@pc_inc_value[0:31] = AND{32} (NOT $alt_pc_inc_value), 4[0:31]
$_pc_clear, @_pc_new, $NULL = ADDER_32BIT $increment_pc, @pc, @pc_inc_value, 0
#display $pc_clear "_pc_new = %32x" @_pc_new[0:31]
$pc_clear = DELAY $_pc_clear
@pc_new = DELAY{2} @_pc_new
// Write back
$_next_stage_PCCLR = DELAY $_pc_clear		; Don't move to decode until PC is updated
#display $_next_stage_PCCLR "next_stage (PCCLR)" 0 
$next_stage = PULSE $_next_stage_PCCLR

// ================================
// === Stage 2: Opcode Decoding ===
// ================================
#array alu_addr 	NUM_GPR_BITS
#array alu_in_dst	NUM_GPR_BITS
#array alu_in_src	NUM_GPR_BITS
#array alu_out  	NUM_GPR_BITS

#display @stage_state[2] "Opcode decode" 1
$decode_enable = OR @stage_state[2:15]
$is_ALU    = AND $decode_enable, (NOT   @instr[31]), (NOT   @instr[30])
$is_BRANCH = AND $decode_enable, (NOT   @instr[31]), (DELAY @instr[30]), (NOT @instr[29])

// === Handle Undefined Opcodes ===
$is_UNDEF = AND (DELAY{2} $decode_enable), (NOR $is_ALU, $is_BRANCH)
#display $is_UNDEF "UNDEFINED INSTRUCTION!" 0
; $next_instruction = AND @stage_state[1], $is_UNDEF

// === Address/Operand Decoding ===
$no_decode_r = AND $decode_enable, (NOR @instr[31:27])
$decode_start = AND $is_ALU, @stage_state[2]
$decode_clear = PULSE @stage_state[4]
$decode_clear = PULSE @stage_state[0]

#display $decode_start "Decode @instr=%32x" @instr
$alu_data_rdy, $addr_is_mem, @alu_addr, @alu_in_dst, @alu_in_src = CPU32_ADDRESS_DECODE \
	$decode_start, $decode_clear, (NOT $no_decode_r), 1, @instr, \
	$reg_enable, @reg_addr, $reg_ready, @reg_data_in, \
	$mem_enable, @mem_addr, $mem_ready, @mem_data_in

#display $alu_data_rdy "@alu_addr   = %32x" @alu_addr[31:0]
#display $alu_data_rdy "@alu_in_dst = %32x" @alu_in_dst[31:0]
#display $alu_data_rdy "@alu_in_src = %32x" @alu_in_src[31:0]

// === ALU Handling ===
$alu_done, $alu_nosave, @alu_out = CPU32_ALU $alu_data_rdy, @instr[27:29], @alu_in_dst, @alu_in_src,\
	$flags_C, $flags_O, $flags_Z, $flags_C_clear, $flags_O_clear, $flags_Z_clear
#display $alu_done "next_stage (ALUDONE)" 0
$next_stage = PULSE $alu_done

// === Conditional Jumps / Calls ===
#array cond 8
@cond = DEMUX{3} $is_BRANCH, @instr[27:25]
$cond_inverse = DELAY @instr[24]
$cond_call = DELAY @instr[28]	// bit 28 selects call/BX (as opposed to just jmp)
$cond_jump = NOT   @instr[28]	// ^^^

$condition_true = AND @cond[0], $flags_Z
$condition_true = AND @cond[1], $flags_C
$condition_true = AND @cond[2], $flags_S
$condition_true = AND @cond[3], $flags_O
$condition_true = AND @cond[4], (NXOR $flags_O, $flags_Z)	; OF!=ZF
$condition_true = AND @cond[5], (NOR $flags_O, $flags_Z)	; OF=0,ZF=0
$condition_true = AND @cond[6], (NOR $flags_C, $flags_Z)	; CF=0,ZF=0
$condition_true = DELAY @cond[7]
$_jump_cond = XOR $condition_true, $cond_inverse

$_next_stage_JMPDEC = DELAY{4} $is_BRANCH
#display $_next_stage_JMPDEC "next_stage (JMPDEC)" 0
$next_stage = PULSE $_next_stage_JMPDEC

#display @stage_state[3] "%1i(_jump_cond) = %1i(condition_true) ^ %1i(cond_inverse)" $_jump_cond, $condition_true, $cond_inverse

// - Not branching? Next instruction
$_ni_NOJMP = AND @stage_state[3], $is_BRANCH, (NOT $_jump_cond)
#display $_ni_NOJMP "Next Instruction (Not Jumping)" 0
$next_instruction = PULSE $_ni_NOJMP

// - Just branch, next stage
$_next_stage_JMP = AND @stage_state[3], $is_BRANCH, $_jump_cond, $cond_jump
#display $_next_stage_JMP "next_stage (JMP)" 0
$next_stage = PULSE $_next_stage_JMP
// - Branch+exchange, save PC to R14
$_do_call = AND @stage_state[3], $is_BRANCH, $_jump_cond, $cond_call
@reg_addr[3:0] = AND{4} $_do_call, 14[3:0]	; R14 = LR
@reg_data_out[31:0] = AND{32} $_do_call, @pc[31:0]
$reg_enable = PULSE $_do_call
$reg_write = PULSE $_do_call
$_next_stage_BXLRSAVED = AND $_do_call, $reg_ready
#display $_next_stage_BXLRSAVED "next_stage (BXLRSAVED)" 0
$next_stage = PULSE $_next_stage_BXLRSAVED

// - Actually do update
$do_jump = AND $is_BRANCH, @stage_state[4]
$alt_pc_inc_value = DELAY $do_jump
@pc_inc_value[31:0] = AND{32} $do_jump, @instr[23],@instr[23],@instr[23],@instr[23],@instr[23],@instr[23],@instr[23:0],0,0 	// 24 bit signed * 4
#display $alt_pc_inc_value "@pc_inc_value = 0x%32x" @pc_inc_value[31:0]
//  > Delay is to ensure the alt_pc_inc_value has taken effect (the hard 0x4 is turned off)
$increment_pc = DELAY (PULSE $do_jump)
// - Next stage when PC is updated
$jump_complete = AND $is_BRANCH, @stage_state[5]
$next_instruction = PULSE $jump_complete


// ==============================
// === Stage 3: Save ALU Data ===
// ==============================
#display @stage_state[3] "Data save" 1
$alu_save = AND @stage_state[3], $is_ALU
// --- Save to memory
$_alu_save_mem = AND $alu_save, (NOT $alu_nosave), $addr_is_mem
#display $_alu_save_mem "Memory 0x%32x = 0x%32x" @alu_addr[31:0], @alu_out[31:0]
@mem_addr     = AND{32} $_alu_save_mem, @alu_addr
@mem_data_out = AND{32} $_alu_save_mem, @alu_out
$mem_write  = DELAY $_alu_save_mem
$mem_enable = DELAY $_alu_save_mem
$_next_stage_ALUMEMSAVE = AND $_alu_save_mem, $mem_ready
#display $_next_stage_ALUMEMSAVE "next_stage (ALUMEMSAVE)" 0
$next_stage = PULSE $_next_stage_ALUMEMSAVE
// --- Save to register
$_alu_save_reg = AND $alu_save, (NOT $alu_nosave), (NOT $addr_is_mem)
#display $_alu_save_reg "Register 0x%4x = 0x%32x" @alu_addr[3:0], @alu_out[31:0]
@reg_addr[3:0] = AND{4} $_alu_save_reg, @alu_addr[3:0]
@reg_data_out = AND{32} $_alu_save_reg, @alu_out
$reg_write = DELAY $_alu_save_reg
$reg_enable = DELAY $_alu_save_reg
$_next_stage_ALUREGSAVE = DELAY{4} $_alu_save_reg
#display $_next_stage_ALUREGSAVE "next_stage (ALUREGSAVE)" 0
$next_stage = PULSE $_next_stage_ALUREGSAVE	// wait for update :)
// --- No writeback
$_alu_save_none = AND $alu_save, $alu_nosave
#display $_alu_save_none "Not saving 0x%32x" @alu_out[31:0]
#display $_alu_save_none "next_stage (ALUNOSAVE)" 0
$next_stage = PULSE $_alu_save_none

// === ALU Done ===
$alu_complete = AND $is_ALU, @stage_state[4]
#display $alu_complete "ALU Complete" 1
$next_instruction = PULSE $alu_complete

#endunit

// ====================================================================
//                             Test Cases
// ====================================================================

// --- Boilerplate for tests ---
%macro __CPU32_TEST_WRAPPER 1
#array flags	NUM_FLAGS
#array flags_clear	NUM_FLAGS
#array reg_addr	4
#array reg_data_in	NUM_GPR_BITS
#array reg_data_out	NUM_GPR_BITS
#array mem_addr	NUM_ADDR_BITS
#array mem_data_in	NUM_GPR_BITS
#array mem_data_out	NUM_GPR_BITS

%if %1 == 1
$ins_end, $mem_enable, @mem_addr, $mem_write, @mem_data_out, \
	$reg_enable, @reg_addr, $reg_write, @reg_data_out, @flags_clear \
	= CPU32_CORE (PULSE 1), $mem_ready, @mem_data_in, $reg_ready, @reg_data_in, @flags
%endif

%endmacro

// --- Test Case : Single instruction ---
#testcase 100 "MOV R15, R15"
__CPU32_TEST_WRAPPER 1

// - Register accesses should only be R15
#testassert $reg_enable @reg_addr[0:3] 15[0:3]
$reg_ready = DELAY $reg_enable
@reg_data_in[31:0] = AND{32} $reg_enable, 0x10F0[31:0]
// - Register write 0x10F0
#testassert $reg_write @reg_data_out[31:0] 0x10F0[31:0]
// - One memory read from 0 (Fetch)
#testassert $mem_enable @mem_addr[31:0] 0x00000000[31:0]
$mem_ready = DELAY $mem_enable
@mem_data_in[0:31] = AND{32} $mem_enable, 0x00FF0000[0:31]
// - Flags should not be changed
#testassert 1 @flags[2:0]	0[2:0]

#testcomplete $ins_end
#endtestcase

// --- Test Case: Two Instructions ---
#testcase 200 "MOV R0, R0; MOV R15, R15"
__CPU32_TEST_WRAPPER 1

#array stage 3
@stage = SEQUENCER{3} 1, 0, $ins_end
// - #1: R0=0x43211234, Mem=0
#testassert @stage[0],$reg_enable  @reg_addr[3:0]  0[3:0]
$reg_ready = AND $reg_enable, @stage[0]
@reg_data_in[31:0] = AND{32} $reg_enable, @stage[0], 0x43211234[31:0]
#testassert @stage[0],$reg_write  @reg_data_out[31:0]  0x43211234[31:0]
#testassert @stage[0],$mem_enable  @mem_addr[31:0]  0x00000000[31:0]
$mem_ready = AND @stage[0], $mem_enable
@mem_data_in[0:31] = AND{32} @stage[0], $mem_enable, 0x00000000[0:31]
// - #2: R15=0xF00DCAFE, Mem=4
#testassert @stage[1],$reg_enable  @reg_addr[3:0]  15[3:0]
$reg_ready = AND @stage[1], $reg_enable
@reg_data_in[31:0] = AND{32} $reg_enable, @stage[1], 0xF00DCAFE[31:0]
#testassert @stage[1],$reg_write  @reg_data_out[31:0]  0xF00DCAFE[31:0]
#testassert @stage[1],$mem_enable @mem_addr[31:0] 0x00000004[31:0]
$mem_ready = AND @stage[1], $mem_enable
@mem_data_in[0:31] = AND{32} @stage[1], $mem_enable, 0x00FF0000[0:31]
// - Flags should not be changed
#testassert 1 @flags[2:0]	0[2:0]

#testcomplete @stage[2]
#endtestcase

#testcase 300 "JMP.Z Y"
__CPU32_TEST_WRAPPER 1
#array stage 3
@stage = SEQUENCER{3} 1, 0, $ins_end
$mem_ready = DELAY $mem_enable
#testassert 1 $reg_enable 0

@mem_data_in[0:31] = AND{32} $mem_enable, 0x40000001[0:31]
@flags[2] = DELAY @stage[0]

#testassert @stage[1],$mem_enable @mem_addr[0:31] 8[0:31]
#testcomplete @stage[2]

#endtestcase

#testcase 1000 "Big PCs"
__CPU32_TEST_WRAPPER 1
#array stage 12
@stage = SEQUENCER{12} 1, 0, $ins_end
$mem_ready = DELAY $mem_enable
#testassert 1 $reg_enable 0

// 0x4F = JMP never
@mem_data_in[0:31] = AND{32} $mem_enable, 0x4F000000[0:31]

#testassert @stage[0],$mem_enable	@mem_addr[0:31]	0x00[0:31]
#testassert @stage[1],$mem_enable	@mem_addr[0:31]	0x04[0:31]
#testassert @stage[2],$mem_enable	@mem_addr[0:31]	0x08[0:31]
#testassert @stage[3],$mem_enable	@mem_addr[0:31]	0x0C[0:31]
#testassert @stage[4],$mem_enable	@mem_addr[0:31]	0x10[0:31]
#testassert @stage[5],$mem_enable	@mem_addr[0:31]	0x14[0:31]
#testassert @stage[6],$mem_enable	@mem_addr[0:31]	0x18[0:31]
#testassert @stage[7],$mem_enable	@mem_addr[0:31]	0x1C[0:31]
#testassert @stage[8],$mem_enable	@mem_addr[0:31]	0x20[0:31]
#testassert @stage[9],$mem_enable	@mem_addr[0:31]	0x24[0:31]
#testassert @stage[10],$mem_enable	@mem_addr[0:31]	0x28[0:31]

#testcomplete @stage[11]
#endtestcase

#testcase 700 "Jump Conditions"
__CPU32_TEST_WRAPPER 1
#array stage 7
@stage = SEQUENCER{7} 1, 0, $ins_end

$mem_ready = DELAY $mem_enable
#testassert 1 $reg_enable 0

// - #1: JMP.N .+16*4 (never)
#testassert @stage[0], $mem_enable @mem_addr[0:31] 0[0:31]
@mem_data_in[0:31] = AND{32} @stage[0], $mem_enable, 0x4F000010[0:31]

// - #2: JMP.A .+1*4 (always)
#testassert @stage[1], $mem_enable @mem_addr[0:31] 4[0:31]
@mem_data_in[0:31] = AND{32} @stage[1], $mem_enable, 0x4E000001[0:31]

// - #3: JMP.Z .+1*4 (zero, fail)
#testassert @stage[2], $mem_enable @mem_addr[0:31] 12[0:31]
@mem_data_in[0:31] = AND{32} @stage[2], $mem_enable, 0x40000001[0:31]

// - #3: JMP.Z .+1*4 (zero, succeed)
#testassert @stage[3], $mem_enable @mem_addr[0:31] 16[0:31]
@mem_data_in[0:31] = AND{32} @stage[3], $mem_enable, 0x40000001[0:31]
@flags[2] = DELAY @stage[3]

// - #4: JMP.A .-4
#testassert @stage[4], $mem_enable @mem_addr[0:31] 24[0:31]
@mem_data_in[0:31] = AND{32} @stage[4], $mem_enable, 0x4EFFFFFF[0:31]

// - Dummy instruction to test the final address
#testassert @stage[5], $mem_enable @mem_addr[0:31] 24[0:31]
@mem_data_in[0:31] = AND{32} @stage[5], $mem_enable, 0x4EFFFFFF[0:31]

#testcomplete @stage[6]

#endtestcase

#testcase 300 "32-Bit ADD (MOVI,MOVI,ADD)"
__CPU32_TEST_WRAPPER 1
#array stage 4
@stage = SEQUENCER{4} 1, 0, $ins_end

$mem_ready = DELAY $mem_enable
$reg_ready, @reg_data_in = REGISTER_BANK_16_32 $reg_enable, @reg_addr, $reg_write, @reg_data_out

// - MOV R0, 0x12345
#testassert @stage[0], $mem_enable  @mem_addr[0:31] 0[0:31]
@mem_data_in[0:31] = AND{32} @stage[0], $mem_enable, 0x01012345[0:31]
#testassert @stage[0], $reg_enable  $reg_write 1
#testassert @stage[0], $reg_enable  @reg_addr[0:3] 0[0:3]
#testassert @stage[0], $reg_enable  @reg_data_out[0:31] 0x12345[0:31]

// - MOV R1, 0xFEDCB
#testassert @stage[1], $mem_enable  @mem_addr[0:31] 4[0:31]
@mem_data_in[0:31] = AND{32} @stage[1], $mem_enable, 0x011FEDCB[0:31]
#testassert @stage[1], $reg_enable  $reg_write 1
#testassert @stage[1], $reg_enable  @reg_addr[0:3] 1[0:3]
#testassert @stage[1], $reg_enable  @reg_data_out[0:31] 0xFEDCB[0:31]

// - ADD R0, R1
#testassert @stage[2], $mem_enable  @mem_addr[0:31] 8[0:31]
@mem_data_in[0:31] = AND{32} @stage[2], $mem_enable, 0x20010000[0:31]
#testassert @stage[2],$reg_write @reg_addr[0:3] 0[0:3]
#testassert @stage[2],$reg_write @reg_data_out[0:31] 0x111110[0:31]

#testcomplete @stage[3]

#endtestcase

// ====================================================================
//                           Root Version
// ====================================================================

// --- FLAGS Pseudo-Register ---
#array flags	NUM_FLAGS
#array flags_clear	NUM_FLAGS
$NULL, @flags[0] = LATCH 1, @flags_clear[0], @flags[0]	// 'C' Flag
$NULL, @flags[1] = LATCH 1, @flags_clear[1], @flags[1]	// 'O' Flag
$NULL, @flags[2] = LATCH 1, @flags_clear[2], @flags[2]	// 'Z' Flag
#display 1 "CF" @flags[0]
#display 1 "OF" @flags[1]
#display 1 "ZF" @flags[2]

// -- GP Registers ---
#array reg_addr	4
#array reg_data_in	32
#array reg_data_out	32
$reg_ready, @reg_data_in = REGISTER_BANK_16_32 $reg_enable, @reg_addr, $reg_write, @reg_data_out
#display $reg_enable "Register Addr" @reg_addr[0:3]
#display $reg_write  "Register Value New %32x" @reg_data_out[NUM_GPR_BITS-1:0]
#display $reg_ready  "Register Value %32x" @reg_data_in[NUM_GPR_BITS-1:0]

// --- Memory ---
#array mem_addr	32
#array mem_data_in	32
#array mem_data_out	32
$mem_ready, @mem_data_in, $fault_ac = MEMORY_SPACE $mem_enable, @mem_addr, $mem_write, @mem_data_out, 0,0
#display $mem_enable "MemAddr" @mem_addr[NUM_ADDR_BITS-1:0]
#display $mem_write "MemOut " @mem_data_out[31:0]
#display $mem_ready "MemIn  " @mem_data_in[NUM_GPR_BITS-1:0]

// --- CPU ---
$rst, $mem_enable, @mem_addr, $mem_write, @mem_data_out, \
	$reg_enable, @reg_addr, $reg_write, @reg_data_out, @flags_clear \
	= CPU32_CORE (PULSE 1), $mem_ready, @mem_data_in, $reg_ready, @reg_data_in, @flags

; vim: ft=logiccircuit
