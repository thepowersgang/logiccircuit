// 32-bit CPU
// By John Hodge (thePowersGang)
// Designed in LogicCircuit
%include "memory.cct"
%include "../adder.cct"
%include "../subber.cct"
%include "../shift_register.cct"
%include "address_decode.cct"
%include "alu.cct"
%include "registers.cct"
%include "common.h.cct"

%define NUM_FLAGS	4

%macro next_stage	3+
$_next_stage_%1 = %3
#display $_next_stage_%1 %2 0
$next_stage = PULSE $_next_stage_%1
%endmacro
%macro next_instruction	3+
$_next_instruction_%1 = %3
#display $_next_instruction_%1 %2 0
$next_instruction = PULSE $_next_instruction_%1
%endmacro

#defunit CPU32_CORE
#input $reset, $mem_ready, @mem_data_in[NUM_GPR_BITS], \
	$reg_ready, @reg_data_in[NUM_GPR_BITS], \
	@flags[NUM_FLAGS]
#output $ins_complete, $mem_enable, @mem_addr[NUM_ADDR_BITS], $mem_write, @mem_data_out[NUM_GPR_BITS], \
	$reg_enable, @reg_addr[4], $reg_write, @reg_data_out[NUM_GPR_BITS], \
	@flags_clear[NUM_FLAGS]

#array stage_num	4
#array stage_state	16

#array instr	32

#breakpoint $ins_complete "Next Instruction"

#display 1 "Stage %4x" @stage_num[3:0], @stage_state
#display 1 "Reset  " $stage_reset
#display 1 "NextS  " $next_stage
#display 1 "instr = 0x%32x" @instr[31:0]
#display 1 "NextI  " $next_instruction

#display $reg_write "R%4i = 0x%32x" @reg_addr[3:0],@reg_data_out[31:0]

$flags_C = @flags[0]
$flags_C_clear = @flags_clear[0]
$flags_O = @flags[1]
$flags_O_clear = @flags_clear[1]
$flags_Z = @flags[2]
$flags_Z_clear = @flags_clear[2]
$flags_S = @flags[3]
$flags_S_clear = @flags_clear[3]

// === Internal Registers ===
// --- Program Counter ---
#array pc	32
#array pc_new	32
#display $pc_clear "PC CLEAR" 0
#display 1 "PC = %32x" @pc[31:0]
$pc_clear = PULSE $reset
$NULL, @pc = LATCH{32} 1, $pc_clear, @pc_new
// --- Control Registers ---
%macro deflreg 1
#array %1	32
#array %1 %+ _new	32
$NULL, @ %+ %1 = LATCH{32} 1, $%1 %+ _clear, @%1 %+ _new
%endmacro
// > CR0: Exception Return
deflreg cr0
// > CR1: Exception Reason
deflreg cr1
// > CR2: MMU Base address + flags
deflreg cr2
// > CR3: System control flags
deflreg cr3
// > CR4 / CR5: Avaliable for OS use
deflreg cr4
deflreg cr5
// > CR6: Pre-Exception R13
deflreg cr6
// > CR7: Pre-Exception FLAGS
deflreg cr7
#display 1 "CR0 = %32x  CR1 = %32x" @cr0[31:0], @cr1[31:0]

// === "Temporary" Latches ===
// @instr - Temporary "variables" used to hold intermediate values
// to be moved to other locations
#display 1 "instr_clear=%1i" $instr_clear
$NULL, @instr = LATCH{32} 1, $instr_clear, @instr
$instr_clear = PULSE @stage_state[0]	// Clear the instruction register

// === Timing control (stages) ===
// 4-bit counter reset by $stage_reset, incremented by $next_stage
// Attached to a 4-bit de-muxer controlling the state of stages
@stage_num = COUNTER{4} $stage_reset, $next_stage
@stage_state = DEMUX{4} 1, @stage_num

// === Next instruction ===
$ins_complete = DELAY{2} (PULSE $next_instruction)
$stage_reset = PULSE $next_instruction
$stage_reset = DELAY $reset

// =============================
// === Stage 0: Opcode Fetch ===
// =============================
#display @stage_state[0] "Opcode fetch" 1
// - Request memory
@mem_addr[2:31] = AND{30} @stage_state[0], @pc[2:31]	// Set memory address to PC (ignore bottom two bits)
$mem_enable  = PULSE @stage_state[0]	// Enable memory for read
// - Read complete, save into @instr
@instr = AND{32} @stage_state[0], $mem_ready, @mem_data_in	// Save the opcode
next_stage OPRDY, "next_stage (OPRDY)", AND @stage_state[0], $mem_ready

// =============================
// === Stage 1: Increment PC ===
// =============================
#display @stage_state[1] "PC Update" 1
// - Add 4 to PC
#array _pc_new 32
#array pc_inc_value 32	// value to increment to
#display @stage_state[1] "PC Inc Value = %32x" @pc_inc_value[31:0]
$increment_pc = PULSE @stage_state[1]	// Increment the program counter too
@pc_inc_value[0:31] = AND{32} (NOT $alt_pc_inc_value), 4[0:31]
$_pc_clear, @_pc_new, $NULL = ADDER_32BIT $increment_pc, @pc, @pc_inc_value, 0
// Write back
$pc_clear = DELAY $_pc_clear
#display $pc_clear "_pc_new = %32x" @_pc_new[0:31]
@pc_new = DELAY{2} @_pc_new
; Don't move to decode until PC is updated
next_stage PCCLR, "next_stage (PCCLR)", DELAY $_pc_clear

// ================================
// === Stage 2: Opcode Decoding ===
// ================================
#array alu_addr 	NUM_GPR_BITS
#array alu_in_dst	NUM_GPR_BITS
#array alu_in_src	NUM_GPR_BITS
#array alu_out  	NUM_GPR_BITS

#display @stage_state[2] "Opcode decode" 1
$decode_enable = OR @stage_state[2:15]
; 0xxxxmmm	- General ALU stuff
$is_ALU     = AND $decode_enable, (NOT @instr[31])
; 100xxxxx	- Conditional branches
$is_BRANCH  = AND $decode_enable, (NXOR{3,2} @instr[31:29], 0b100[2:0])
; 1010xmmm xxxxxxxx	- Indirect Branch
$is_IBRANCH = AND $decode_enable, (NXOR{4,2} @instr[31:28], 0b1010[3:0])
; 10110mmm 0000xxxx	- Push
$is_PUSH    = AND $decode_enable, (NXOR{9,2} @instr[31:27],@instr[23:20], 0b101100000[8:0])
; 10110mmm 0001xxxx	- Pop
$is_POP     = AND $decode_enable, (NXOR{9,2} @instr[31:27],@instr[23:20], 0b101100001[8:0])
; 10110mmm 001xxxxx	- BSWAP[W]
;$is_BSWAP   = AND $decode_enable, (NXOR{8,2} @instr[31:27],@instr[23:21], 0b01100001[7:0])
; 10111000 00000000	- Load Flags
$is_LDF     = AND $decode_enable, (NXOR{16,2} @instr[31:16], 0xB800[15:0])
; 10111000 00000001 00000000	- MCR
$is_MCR     = AND $decode_enable, (XNOR{24,2} @instr[31:8], 0xB80100[23:0])
; 10111000 00000001 00000001	- MRC
$is_MRC     = AND $decode_enable, (XNOR{24,2} @instr[31:8], 0xB80101[23:0])
; 10111000 0000001x	- Shift / Rotate
$is_SHIFT   = AND $decode_enable, (XNOR{15,2} @instr[31:17], 0xB802[15:1])
; 101111mm	- LEA R, op2
$is_LEA     = AND $decode_enable, (NXOR{6,2} @instr[31:26], 0b101111[5:0])
; 1100xxxx	- Non-word Load/Store
;$is_NONWLS  = AND $decode_enable, (NXOR{4,2} @instr[31:28], 0b1100[3:0])

#array interrupt_num	4
// === Handle Undefined Opcodes ===
$is_invl = NOR $is_ALU, $is_BRANCH, $is_IBRANCH, $is_PUSH, $is_POP, $is_LDF, $is_MRC, $is_MCR, $is_SHIFT, $is_LEA
$is_UNDEF = AND (DELAY{2} $decode_enable), $is_invl
#display $is_UNDEF "UNDEFINED INSTRUCTION!" 0
#breakpoint $is_UNDEF "#UD"
; - Set CRs
$cr1_clear = PULSE $is_UNDEF
@cr1_new = AND{32} (PULSE $is_UNDEF), @instr
; - Trip interrupt circuitry (Interrupt 2 - #UD)
$is_interrupt = DELAY{3} $is_UNDEF
@interrupt_num[0:3] = AND{4} $is_UNDEF, 2[0:3]	; 0x00000008 / 4

// --- Interrupt / Exception Handling ---
// - Set CR0=PC
$_intr_pulse = PULSE $is_interrupt
$cr0_clear = DELAY $_intr_pulse
@cr0_new = AND{32} (PULSE $_intr_pulse), @pc
// - Set CR6=SP
$cr6_clear = DELAY $_intr_pulse
$reg_enable = DELAY $_intr_pulse
@reg_addr[0:3] = AND{4} $_intr_pulse, 13[0:3]
@cr6_new[0:31] = AND{32} $is_interrupt, $reg_ready, @reg_data_in[0:31]
// - Set CR7=flags
$cr7_clear = DELAY $_intr_pulse
@cr7_new[0:31] = AND{32} (PULSE $_intr_pulse), @flags[0:3],0*28
// - Set PC=handler
$pc_clear = DELAY{2} $_intr_pulse
@pc_new[0:31] = DELAY{2} (AND{32} $_intr_pulse, 0,0,@interrupt_num[0:3],0*26)
next_instruction Intr, "next_instruction (Intr)", DELAY{3} $_intr_pulse

// === Address/Operand Decoding ===
$no_decode_r = AND $decode_enable, $is_IBRANCH
$no_decode_r = AND $decode_enable, (NXOR{5,2} @instr[31:27], 0b00000[4:0])	// MOV
$no_read_m   = AND $decode_enable, (NXOR{5,2} @instr[31:27], 0b01000[4:0])	// Reversed MOV
$no_decode_r = AND $decode_enable, $is_PUSH
$no_decode_r = AND $decode_enable, $is_POP
$no_read_m   = AND $decode_enable, $is_POP
$switch_operands = AND $decode_enable, $is_POP
$no_read_m       = AND $decode_enable, $is_LEA
$no_decode_r     = AND $decode_enable, $is_LEA
$switch_operands = AND $decode_enable, $is_LEA
// - Swap ALU operands
$switch_operands = AND $decode_enable, $is_ALU, @instr[30]

$decode_start = AND @stage_state[2], $is_ALU
$decode_start = AND @stage_state[2], $is_IBRANCH
$decode_start = AND @stage_state[2], $is_PUSH
$decode_start = AND @stage_state[2], $is_POP
$decode_start = AND @stage_state[2], $is_LEA
;$decode_clear = PULSE @stage_state[4]
$decode_clear = PULSE @stage_state[0]

#display $decode_start "Decode @instr=%32x" @instr
$decode_complete, $addr_is_mem, @alu_addr, @alu_in_dst, @alu_in_src,\
	$reg_enable, @reg_addr, $mem_enable, @mem_addr = CPU32_ADDRESS_DECODE \
	$decode_start, $decode_clear, $switch_operands, (NOT $no_decode_r), (NOT $no_read_m), @instr[0:26], \
	$reg_ready, @reg_data_in, $mem_ready, @mem_data_in, @pc

#display $decode_enable "$addr_is_mem = %1i" $addr_is_mem
#display $decode_complete "@alu_addr   = %32x" @alu_addr[31:0]
#display $decode_complete "@alu_in_dst = %32x" @alu_in_dst[31:0]
#display $decode_complete "@alu_in_src = %32x" @alu_in_src[31:0]
//next_stage DecodeComplete, "next_stage (Decode Complete)", $decode_complete
//next_stage DecodeSkipped, "next_stage (Decode Skipped)", AND (DELAY{3} $decode_enable), (NOT $decode_start)

// --- Stage 2.5 ALU Core ---
$alu_data_rdy = AND $is_ALU, $decode_complete
$alu_done, $alu_nosave, @alu_out, $flags_C_clear, $flags_O_clear, $flags_Z_clear \
	= CPU32_ALU $alu_data_rdy, @instr[27:29], @alu_in_dst, @alu_in_src,\
	$flags_C, $flags_O, $flags_Z
next_stage ALUDONE, "next_stage (ALUDONE)", $alu_done
// --- Stage 3: Save ALU Data ---
#display $is_ALU,@stage_state[3] "Data save" 1
$alu_save = AND @stage_state[3], $is_ALU
// - Save to memory
$_alu_save_mem = AND $alu_save, (NOT $alu_nosave), $addr_is_mem
#display $_alu_save_mem "Memory 0x%32x = 0x%32x" @alu_addr[31:0], @alu_out[31:0]
@mem_addr     = AND{32} $_alu_save_mem, @alu_addr
@mem_data_out = AND{32} $_alu_save_mem, @alu_out
$mem_write  = DELAY $_alu_save_mem
$mem_enable = PULSE $_alu_save_mem
next_stage ALUMEMSAVE, "next_stage (ALUMEMSAVE)", AND $_alu_save_mem, $mem_ready
// - Save to register
$_alu_save_reg = AND $alu_save, (NOT $alu_nosave), (NOT $addr_is_mem)
#display $_alu_save_reg "Register 0x%4x = 0x%32x" @alu_addr[3:0], @alu_out[31:0]
@reg_addr[3:0] = AND{4} $_alu_save_reg, @alu_addr[3:0]
@reg_data_out = AND{32} $_alu_save_reg, @alu_out
$reg_write = DELAY $_alu_save_reg
$reg_enable = PULSE $_alu_save_reg
next_stage ALUREGSAVE, "next_stage (ALUREGSAVE)", DELAY{4} $_alu_save_reg
// - No writeback
next_stage ALUNOSAVE, "next_stage (ALUNOSAVE)", AND $alu_save, $alu_nosave
#display $_next_stage_ALUNOSAVE "Not saving 0x%32x" @alu_out[31:0]
// --- ALU Done ---
next_instruction ALUCOMPLETE, "next_instruction (ALU Complete)", AND $is_ALU, @stage_state[4]

// ((( Stack Adder ))
#array _sp_addend 32
$reg_write,@reg_data_out,$NULL = ADDER_32BIT $_sp_add_update, @reg_data_in, @_sp_addend, 0
// === Push ===
next_stage PushDataAvail, "next_stage (Push Data Avaliable)", AND $is_PUSH, $decode_complete
// - Subtract 4 from SP (R13)
$_push_regen = OR @stage_state[3], @stage_state[4]
$reg_enable = AND $is_PUSH, $_push_regen
@reg_addr[0:3] = AND{4} $is_PUSH, $_push_regen, 13[0:3]
$_push_sp_ready = AND $is_PUSH, @stage_state[3], $reg_ready
$_sp_add_update = DELAY $_push_sp_ready
@_sp_addend[0:31] = AND{32} $is_PUSH, 0xFFFFFFFC[0:31]
next_stage PushSPUpdated, "next_stage (Push SP Updated)", AND $is_PUSH, @stage_state[3], $reg_write
// - Write data to [SP]
$_push_save = PULSE (AND $is_PUSH, @stage_state[4])
$mem_enable = DELAY $_push_save
$mem_write = DELAY $_push_save
@mem_addr = AND{32} $_push_save, @reg_data_in
@mem_data_out = AND{32} $_push_save, @alu_in_src
// - Data written, instruction complete
next_instruction Push, "next_instruction (Push)", DELAY{3} $_push_save
// === Pop ===
next_stage PopDestAvail, "next_stage (Push Data Avaliable)", AND $is_POP, $decode_complete
#array _pop_data	32
@_pop_data = @alu_in_dst	// (ab)use ALU latch
// - Read SP and get memory
$_pop_read = AND $is_POP, @stage_state[3]
$reg_enable = PULSE $_pop_read
@reg_addr[0:3] = AND{4} $_pop_read, 13[0:3]
$mem_enable = AND $_pop_read, $reg_ready
@mem_addr = AND{32} $_pop_read, $reg_ready, @reg_data_in
@_pop_data = AND{32} $_pop_read, $mem_ready, @mem_data_in
next_stage PopDataLoaded, "next_stage (Pop Data Loaded)", AND $_pop_read, $mem_ready
// - Update SP
$_pop_updatesp = AND $is_POP, @stage_state[4]
$reg_enable = DELAY $_pop_updatesp
@reg_addr[0:3] = AND{4} $_pop_updatesp, 13[0:3]
$_sp_add_update = PULSE (AND $_pop_updatesp, $reg_ready)
@_sp_addend[0:31] = AND{32} $is_POP, 4[0:31]
next_stage PopSPUpdated, "next_stage (Pop SP Updated)", AND $is_POP, @stage_state[4], $reg_write
// - Save data
$_pop_save = AND $is_POP, @stage_state[5]
$alu_save = DELAY $_pop_save
@alu_out = AND{32} $_pop_save, @_pop_data
%if 0
$_pop_regsave = AND $is_POP, @stage_state[5], (NOT   $addr_is_mem)
#display $_pop_regsave "Saving to register %5i" @alu_addr[4:0]
$reg_enable = DELAY $_pop_regsave
@reg_addr[0:3] = AND{4} $_pop_regsave, @alu_addr[0:3]
$reg_write = DELAY $_pop_regsave
@reg_data_out[0:31] = AND{32} $_pop_regsave, @_pop_data[0:31]
next_stage PopSavedReg, "next_stage (POP Saved to reg)", AND $_pop_regsave, $reg_ready
$_pop_memsave = AND $is_POP, @stage_state[5], (DELAY $addr_is_mem)
#display $_pop_memsave "Saving to mem 0x%32x" @alu_addr[31:0]
$mem_enable = DELAY $_pop_memsave
@mem_addr[0:31] = AND{32} $_pop_memsave, @alu_addr[0:31]
$mem_write = DELAY $_pop_memsave
@mem_data_out[0:31] = AND{32} $_pop_memsave, @_pop_data[0:31]
next_stage PopSavedMem, "next_stage (POP Saved to memory)", AND $_pop_memsave, $mem_ready
%endif
// - Instruction complete
next_instruction Pop, "next_instruction (Pop)", AND $is_POP, @stage_state[6]

// === BSWAP(W) ===
// TODO: Impliment BSWAP(W)
// TODO: a) Is this needed, b) Should it be reg-reg instead of reg-mem?

// === Load Flags (LDF) ===
@flags_clear[0:3] = AND{4} (PULSE $is_LDF), (NOT   @instr[8:11])
@flags[0:3]       = AND{4} (PULSE $is_LDF), (DELAY @instr[0:3])
next_instruction LDF, "next_instruction (LDF)", DELAY{3} $is_LDF

#array _cr_wr_sel	16
#array cr_data_set 32
@_cr_wr_sel = DEMUX{4} $cr_sel_write, @instr[4:7]
$cr0_clear = PULSE @_cr_wr_sel[0] \\ @cr0_new = AND{32} @_cr_wr_sel[0], @cr_data_set
$NULL = DELAY @_cr_wr_sel[1]	// CR1: Read-only
$cr2_clear = PULSE @_cr_wr_sel[2] \\ @cr2_new = AND{32} @_cr_wr_sel[2], @cr_data_set
$cr3_clear = PULSE @_cr_wr_sel[3] \\ @cr3_new = AND{32} @_cr_wr_sel[3], @cr_data_set
$cr4_clear = PULSE @_cr_wr_sel[4] \\ @cr4_new = AND{32} @_cr_wr_sel[4], @cr_data_set
$cr5_clear = PULSE @_cr_wr_sel[5] \\ @cr5_new = AND{32} @_cr_wr_sel[5], @cr_data_set
$cr6_clear = PULSE @_cr_wr_sel[6] \\ @cr6_new = AND{32} @_cr_wr_sel[6], @cr_data_set
$cr7_clear = PULSE @_cr_wr_sel[7] \\ @cr7_new = AND{32} @_cr_wr_sel[7], @cr_data_set
$NULL = OR @_cr_wr_sel[8:15]
// === MCR ===
$reg_enable = DELAY $is_MCR
@reg_addr[0:3] = AND{4} $is_MCR, @instr[0:3]
$cr_sel_write = AND $reg_ready, $is_MCR
@cr_data_set = DELAY{2} @reg_data_in
next_instruction MCR, "next_instruction (MCR)", DELAY{2} (AND $reg_ready, $is_MCR)

// === MRC ===
$reg_enable = PULSE $is_MRC
@reg_addr[0:3] = AND{4} $is_MRC, @instr[0:3]
$reg_write = PULSE $is_MRC
@reg_data_out = MUX{4,32} $is_MRC, @instr[4:7], @cr0,@cr1, @cr2,@cr3, @cr4,@cr5, @cr6,@cr7, 0*256
next_instruction MRC, "next_instruction (MRC)", DELAY{4} $is_MRC

// === Shift / Rotate ===
#array _shift_count 5
#array _shift_value 33
#array _shift_value_nc 32
#array _shift_out 33
#array _shift_out_nc 32
// Use ALU latches for temp storage
// - This is a little evil, as these latches are in CPU32_ADDRESS_DECODE
@_shift_count[0:4] = @alu_in_src[0:4]
#display $is_SHIFT "_shift_count = 0x%5x" @_shift_count[4:0]
@_shift_value[0:31] = @alu_in_dst[0:31]
@_shift_value[32] = @alu_in_src[16]
@_shift_value_nc[0:31] = @alu_addr[0:31]
$_shift_dir_left  = NOT   @instr[7]
$_shift_dir_right = DELAY @instr[7]
$_shift_no_cf  = NOT   @instr[6]
$_shift_use_cf = DELAY @instr[6]
$_shift_is_shift  = NOT   @instr[16]
$_shift_is_rotate = DELAY @instr[16]
// Prepare arguments
// - Count imm5
@_shift_count[0:4] = AND{5} $is_SHIFT, (DELAY @instr[5]), @instr[0:4]
next_stage ShiftImm5, "next_stage (Shift Imm5)", AND $is_SHIFT, @stage_state[2], (DELAY @instr[5])
// - Count r
$_shift_readRv = AND $is_SHIFT, @stage_state[2], (NOT @instr[5])
$reg_enable = AND $_shift_readRv
@reg_addr[0:3] = AND{4} $_shift_readRv, @instr[0:3]
@_shift_count[0:4] = AND{5} $_shift_readRv, $reg_ready, @reg_data_in[0:4]
next_stage ShiftRv, "next_stage (Shift Rv)", AND $_shift_readRv, $reg_ready
// - Value
$_shift_value_reading = AND $is_SHIFT, @stage_state[3]
$reg_enable = PULSE $_shift_value_reading
@reg_addr[0:3] = AND{4} $_shift_value_reading, @instr[8:11]
#display $_shift_value_reading,$reg_ready "Shift reg in: %32x" @reg_data_in[31:0]
@_shift_value[0:32] = AND{33} $_shift_value_reading,$reg_ready,$_shift_dir_left,  $flags_C,@reg_data_in[0:31]
@_shift_value[0:32] = AND{33} $_shift_value_reading,$reg_ready,$_shift_dir_right, @reg_data_in[31:0],$flags_C
@_shift_value_nc[0:31] = AND{32} $_shift_value_reading,$reg_ready,$_shift_dir_left,  @reg_data_in[0:31]
@_shift_value_nc[0:31] = AND{32} $_shift_value_reading,$reg_ready,$_shift_dir_right, @reg_data_in[31:0]
next_stage ShiftVal, "next_stage (Shift Value)", AND $_shift_value_reading, $reg_ready
// Clear CF if it is used
$flags_C_clear = PULSE (AND $is_SHIFT, @stage_state[4], $_shift_use_cf)
$_shl_enable = AND $is_SHIFT, @stage_state[4], $_shift_is_shift
;$_shl_enable = AND $is_SHIFT, @stage_state[4], (NOT   @instr[16]), $_shift_no_cf
;$_scl_enable = AND $is_SHIFT, @stage_state[4], (NOT   @instr[16]), $_shift_use_cf
$_rol_enable = AND $is_SHIFT, @stage_state[4], $_shift_is_rotate, $_shift_no_cf
$_rcl_enable = AND $is_SHIFT, @stage_state[4], $_shift_is_rotate, $_shift_use_cf
// Perform shift
#display 1 "SHL: _shift_value = %33x" @_shift_value
#display $_shl_enable "SHL: _shift_value = %33x" @_shift_value[32:0]
;#display $_scl_enable "SCL: _shift_value = %33x" @_shift_value
;#display $_shl_enable "SHL: _shift_value = %32x" @_shift_value_nc
#display $_rcl_enable "RCL: _shift_value = %33x" @_shift_value[32:0]
#display $_rol_enable "ROL: _shift_value = %32x" @_shift_value_nc[31:0]
$_shift_done, @_shift_out    = SHIFT_LEFT_N_32  $_shl_enable, @_shift_count, @_shift_value
$_shift_done, @_shift_out    = ROTATE_LEFT_N_33 $_rcl_enable, @_shift_count, @_shift_value
$_shift_done, @_shift_out_nc = ROTATE_LEFT_N_32 $_rol_enable, @_shift_count, @_shift_value_nc
next_stage ShiftDone, "next_stage (Shift Done)", $_shift_done
#display $_shift_done,$_shift_dir_left  "_shift_out CL = %32x,C=%1b" @_shift_out[32:1],@_shift_out[0]
#display $_shift_done,$_shift_dir_right "_shift_out CR = %32x,C=%1b" @_shift_out[0:31],@_shift_out[32]
#display $_shift_done,$_shift_dir_left  "_shift_out -L = %32x" @_shift_out_nc[31:0]
#display $_shift_done,$_shift_dir_right "_shift_out -R = %32x" @_shift_out_nc[0:31]
// Write back shifted value
$_shift_writeback = AND $is_SHIFT, @stage_state[5]
$reg_write = PULSE $_shift_writeback
@reg_addr[0:3] = AND{4} $_shift_writeback, @instr[12:15]
$reg_enable = PULSE $_shift_writeback
$flags_C,@reg_data_out[0:31] = AND{33} $_shift_writeback,$_shift_dir_left,  @_shift_out[0:32]
@reg_data_out[31:0],$flags_C = AND{33} $_shift_writeback,$_shift_dir_right, @_shift_out[0:32]
@reg_data_out[0:31]          = AND{32} $_shift_writeback,$_shift_dir_left,  @_shift_out_nc[0:31]
@reg_data_out[31:0]          = AND{32} $_shift_writeback,$_shift_dir_right, @_shift_out_nc[0:31]
// Operation complete
next_instruction Shift, "next_instruction (Shift)", DELAY{5} $_shift_writeback

// === Load Effective Address (LEA) ===
$_LEA_active = AND $is_LEA, $decode_complete
$reg_enable = PULSE $_LEA_active
$reg_write = PULSE $_LEA_active
@reg_addr[0:3] = AND{4} $_LEA_active, @instr[20:23]
@reg_data_out[0:31] = AND{32} $_LEA_active, @alu_addr[0:31]
next_instruction LEA, "next_instruction (LEA)", DELAY{3} $_LEA_active

// === Non-word Load/Store ===
#array _nwls_basereg	4
#array _nwls_datareg	4
#array _nwls_offset	32
@_nwls_basereg = @instr[16:19]
@_nwls_datareg = @instr[20:23]
$_nwls_offset_sign = @instr[15]
@_nwls_offset[0:15] = @instr[0:15] \\ @_nwls_offset[16:31] = $_nwls_offset_sign*16
$_nwls_byteop = AND $is_NONWLS, @instr[27]
$_nwls_byteop = AND $is_NONWLS, (XNOR @instr[27:25], 0b011[2:0])
$_nwls_hwordop = AND $is_NONWLS, (XNOR @instr[27:26], 0b00[1:0])
$_nwls_hwordop = AND $is_NONWLS, (XNOR @instr[27:25], 0b010[2:0])
// - Get Address
#array _nwls_baseaddr	32
#array _nwls_addr	32
@_nwls_addr = @alu_addr	// (ab)use ALU address latch
$_nwls_getaddr = AND $is_NONWLS, @stage_state[2]
$reg_enable = DELAY $_nwls_getaddr
@reg_addr = AND{4} $_nwls_getaddr, @_nwls_basereg
$_nwls_startadd = AND $_nwls_getaddr, $reg_ready
@_nwls_baseaddr = AND{32} $_nwls_getaddr, $reg_ready, @reg_data_out
$_nwls_add_complete, @_nwls_addr, $NULL = ADDER_32BIT $_nwls_startadd, @_nwls_baseaddr, @_nwls_offset, 0
next_stage NWLSGetAddr, "next_stage (NWLS Get Address)", DELAY $_nwls_add_complete
// - GP load section
#array _nwls_rdbyte 4
#array _nwls_rdword 2
#array _nwls_data 32
@_nwls_data = @alu_in_dst	// (ab)use ALU destination latch
$mem_enable = DELAY $_nwls_doread
;@mem_size = AND{2} $_nwls_doread, $_nwls_byteop, 0b00[0:1]
@mem_addr = AND{32} $_nwls_doread, @_nwls_baseaddr
@_nwls_rdword = DEMUX{1} $_nwls_hwordop, @_nwls_baseaddr[1]
@_nwls_rdbyte = DEMUX{2} $_nwls_byteop, @_nwls_baseaddr[0], @_nwls_baseaddr[1]
@_nwls_data[0:7] = AND{8} @_nwls_rdbyte[0], $mem_ready, @mem_data_in[ 0: 7]
@_nwls_data[0:7] = AND{8} @_nwls_rdbyte[1], $mem_ready, @mem_data_in[ 8:15]
@_nwls_data[0:7] = AND{8} @_nwls_rdbyte[2], $mem_ready, @mem_data_in[16:23]
@_nwls_data[0:7] = AND{8} @_nwls_rdbyte[3], $mem_ready, @mem_data_in[24:31]
@_nwls_data[0:15] = AND{16} @_nwls_rdword[0], $mem_ready, @mem_data_in[ 0:15]
@_nwls_data[0:15] = AND{16} @_nwls_rdword[1], $mem_ready, @mem_data_in[0:15]
$_nwls_datardy = AND (OR $_nwls_hwordop, $_nwls_byteop), $mem_ready
// - Handle Zero/Sign extend load
// - Handle non-extended load
// - Handle stores

// === Conditional Jumps / Calls ===
#array cond 8
@cond = DEMUX{3} $is_BRANCH, @instr[27:25]
$cond_inverse = AND $is_BRANCH, @instr[24]
$cond_call = AND $is_BRANCH, (DELAY @instr[28])	// bit 28 selects call/BX (as opposed to just jmp)
$cond_jump = AND $is_BRANCH, (NOT   @instr[28])	// ^^^
@cond = DEMUX{3} $is_IBRANCH, @instr[23:21]
$cond_inverse = AND $is_IBRANCH, @instr[20]
$cond_call = AND $is_IBRANCH, (DELAY @instr[27])	// bit 27 selects call/BX (as opposed to just jmp)
$cond_jump = AND $is_IBRANCH, (NOT   @instr[27])	// ^^^

$condition_true = AND @cond[0], $flags_Z
$condition_true = AND @cond[1], $flags_C
$condition_true = AND @cond[2], $flags_S
$condition_true = AND @cond[3], $flags_O
$condition_true = AND @cond[4], (NXOR $flags_O, $flags_Z)	; OF!=ZF
$condition_true = AND @cond[5], (NOR $flags_O, $flags_Z)	; OF=0,ZF=0
$condition_true = AND @cond[6], (NOR $flags_C, $flags_Z)	; CF=0,ZF=0
$condition_true = DELAY @cond[7]
$_jump_cond = XOR $condition_true, $cond_inverse

next_stage JMPDEC, "next_stage (JMPDEC)", DELAY{4} $is_BRANCH
next_stage IJMPDEC, "next_stage (IJMPDEC)", AND $is_IBRANCH, $decode_complete

#display $is_BRANCH,@stage_state[3] "%1i(jmpcond) = %1i(condition_true) ^ %1i(cond_inverse)" $_jump_cond, $condition_true, $cond_inverse
#display $is_IBRANCH,@stage_state[3] "%1i(jmpcond) = %1i(condition_true) ^ %1i(cond_inverse)" $_jump_cond, $condition_true, $cond_inverse

// - Not branching? Next instruction
next_instruction NOJMP, "next_instruction (Not Jumping)", AND @stage_state[3], (OR $is_IBRANCH, $is_BRANCH), (NOT $_jump_cond)

// - Just branch, next stage
next_stage JMP,  "next_stage (JMP)",  AND @stage_state[3], $is_BRANCH, $_jump_cond, $cond_jump
next_stage IJMP, "next_stage (IJMP)", AND @stage_state[3], $is_IBRANCH, $_jump_cond, $cond_jump
// - Branch+exchange, save PC to R14
$_do_call = AND @stage_state[3], $is_BRANCH, $_jump_cond, $cond_call
@reg_addr[3:0] = AND{4} $_do_call, 14[3:0]	; R14 = LR
@reg_data_out[31:0] = AND{32} $_do_call, @pc[31:0]
$reg_enable = PULSE $_do_call
$reg_write = PULSE $_do_call
next_stage BXLRSAVED, "next_stage (BXLRSAVED)", AND $_do_call, $reg_ready

// - Actually do update
$do_jump = AND $is_BRANCH, @stage_state[4]
$alt_pc_inc_value = DELAY $do_jump
$_jmp_sign_bit = @instr[23]
@pc_inc_value[31:0] = AND{32} $do_jump, $_jmp_sign_bit*6, @instr[23:0],0,0 	// 24 bit signed * 4
#display $alt_pc_inc_value "@pc_inc_value = 0x%32x" @pc_inc_value[31:0]
//  > Delay is to ensure the alt_pc_inc_value has taken effect (the hard 0x4 is turned off)
$increment_pc = DELAY (PULSE $do_jump)
// - Next stage when PC is updated
next_instruction JMP, "next_instruction (Branch Complete)", AND $is_BRANCH, @stage_state[5]
// -- IJMP - Set PC
$do_ijump = AND $is_IBRANCH, @stage_state[4]
$pc_clear = DELAY $do_ijump
@pc = AND{32} (DELAY{2} $do_ijump), @alu_in_src
next_instruction IJMP, "next_instruction (IBranch Complete)", DELAY{5} $do_ijump

#endunit

%include "CPU-32_tests.cct"

// ====================================================================
//                           Root Version
// ====================================================================

// --- FLAGS Pseudo-Register ---
#array flags	NUM_FLAGS
#array flags_clear	NUM_FLAGS
$NULL, @flags[0] = LATCH 1, @flags_clear[0], @flags[0]	// 'C' Flag
$NULL, @flags[1] = LATCH 1, @flags_clear[1], @flags[1]	// 'O' Flag
$NULL, @flags[2] = LATCH 1, @flags_clear[2], @flags[2]	// 'Z' Flag
$NULL, @flags[3] = LATCH 1, @flags_clear[3], @flags[3]	// 'S' Flag
#display 1 "CF" @flags[0]
#display 1 "OF" @flags[1]
#display 1 "ZF" @flags[2]
#display 1 "SF" @flags[3]

// -- GP Registers ---
#array reg_addr	4
#array reg_data_in	32
#array reg_data_out	32
$reg_ready, @reg_data_in = REGISTER_BANK_16_32 $reg_enable, @reg_addr, $reg_write, @reg_data_out
#display $reg_enable "Register Addr" @reg_addr[0:3]
#display $reg_write  "Register Value New %32x" @reg_data_out[NUM_GPR_BITS-1:0]
#display $reg_ready  "Register Value %32x" @reg_data_in[NUM_GPR_BITS-1:0]

// --- Memory ---
#array mem_addr	32
#array mem_data_in	32
#array mem_data_out	32
$mem_ready, @mem_data_in, $NULL = MEMORY_SPACE $mem_enable, @mem_addr, $mem_write, @mem_data_out, 0,0
#display $mem_enable "MemAddr" @mem_addr[NUM_ADDR_BITS-1:0]
#display $mem_write "MemOut " @mem_data_out[31:0]
#display $mem_ready "MemIn  " @mem_data_in[NUM_GPR_BITS-1:0]

// --- CPU ---
$rst = PULSE 1
$instr_pulse, $mem_enable, @mem_addr, $mem_write, @mem_data_out, \
	$reg_enable, @reg_addr, $reg_write, @reg_data_out, @flags_clear \
	= CPU32_CORE $rst, $mem_ready, @mem_data_in, $reg_ready, @reg_data_in, @flags

; vim: ft=logiccircuit
