// 32-bit CPU
// By John Hodge (thePowersGang)
// Designed in LogicCircuit
%include "memory.cct"
%include "../adder.cct"
%include "../subber.cct"
%include "../shift_register.cct"
%include "address_decode.cct"
%include "registers.cct"

%define	NUM_GPR_BITS	32
%define	NUM_ADDR_BITS	32

#array mem_data_in NUM_GPR_BITS
#array mem_data_out NUM_GPR_BITS
#array mem_addr NUM_ADDR_BITS

#array reg_data_in NUM_GPR_BITS
#array reg_data_out NUM_GPR_BITS
#array reg_addr 	4

#array stage_num	4
#array stage_state	16

#array instr	32

#breakpoint $next_stage "Next Stage"
#breakpoint $reg_pc_write "PC Write"
#breakpoint $stage_reset "Stage Reset"

#display 1 "Clock  " $clock
#display 1 "Stage %4x" @stage_num[3:0], @stage_state
#display 1 "Reset  " $stage_reset
#display 1 "NextS  " $next_stage
#display 1 "instr = 0x%32x" @instr[31:0]
#display 1 "NextI  " $next_instruction

// Instruction clock (used to ensure synchronisation)
// In each 128 cycles, the clock is high for one
// TODO: Determine how many logic cycles are needed to run the CPU
//       - Maybe have @stage_state[15] map to reset (or map others via an
//         AND with $is_*)
// NOTE: Unused really
$clock = CLOCK{128}

// === Registers ===
$reg_ready, @reg_data_in = REGISTER_BANK_16_32 $reg_enable, @reg_addr, $reg_write, @reg_data_out

// --- FLAGS Pseudo-Register ---
$NULL, $flags_C = LATCH 1, $flags_C_clear, $flags_C
$NULL, $flags_O = LATCH 1, $flags_O_clear, $flags_O
$NULL, $flags_Z = LATCH 1, $flags_Z_clear, $flags_Z
#display 1 "CF" $flags_C
#display 1 "OF" $flags_O
#display 1 "ZF" $flags_Z

#display $reg_enable "Register Addr" @reg_addr[0:3]
#display $reg_write  "Register Value New %32x" @reg_data_out[NUM_GPR_BITS-1:0]
#display $reg_ready  "Register Value %32x" @reg_data_in[NUM_GPR_BITS-1:0]

// === Memory ===
// TODO: Maybe have these lines be arguments of some form
// TODO: Implement non-dword reads
$mem_ready, @mem_data_in, $fault_ac = MEMORY_SPACE $mem_enable, @mem_addr, $mem_data_write, @mem_data_out, 0,0
#display $mem_enable "MemAddr" @mem_addr[NUM_ADDR_BITS-1:0]
#display $mem_write "MemOut " @mem_data_out[31:0]
#display $mem_ready "MemIn  " @mem_data_in[NUM_GPR_BITS-1:0]

// === "Temporary" Latches ===
// @instr - Temporary "variables" used to hold intermediate values
// to be moved to other locations
#display 1 "instr_clear=%1i" $instr_clear
$NULL, @instr = LATCH{32} 1, $instr_clear, @instr

// === Timing control (stages) ===
// 4-bit counter reset by $stage_reset, incremented by $next_stage
// Attached to a 4-bit de-muxer controlling the state of stages
@stage_num = COUNTER{4} $stage_reset, $next_stage
@stage_state = DEMUX{4} 1, @stage_num

// === Next instruction ===
$stage_reset = PULSE $next_instruction

// === PC Increment ===
$reg_pc_invalidate = $increment_pc	// Invalidate PC when increment is called
// Add 1 to the PC register (if $increment_pc is set)
// - Assigning to reg_pc_(write|out) causes it to update the register
//   once done
$reg_pc_valid = DELAY{6} $reg_pc_write	// TODO: Fine tune this to the write delay of a word register
$reg_pc_valid = PULSE 1	// Raise at CPU init
$NULL, $reg_pc_valid  = LATCH 1, $reg_pc_invalidate, $reg_pc_valid
#display 1 "PC Valid? %1i" $reg_pc_valid

// Reset all values
$instr_clear = PULSE @stage_state[0]	// Clear the instruction register

// === Stage 0: Opcode Fetch ===
// STAGE0 - Opcode Fetch
#display @stage_state[0] "Opcode fetch" 1
// - Read register
$reg_enable = PULSE @stage_state[0]
@reg_addr = CONST{4,15} @stage_state[0]
// - Request memory
@mem_addr = DELAY (AND{NUM_ADDR_BITS} @stage_state[0], $reg_ready, @reg_data_in)	// Set memory address to PC
$mem_enable  = PULSE (AND @stage_state[0], $reg_ready)	// Enable memory for read
// - Read complete, save into @instr
@instr = AND{32} @stage_state[0], $mem_ready, @mem_data_in	// Save the opcode
$next_stage = PULSE (AND @stage_state[0], $mem_ready)	// Wait for instruction to be fetched
// === Stage 1: Increment PC ===
#display @stage_state[1] "PC Update" 1
#array new_pc	32
// - Get PC value
$reg_enable = PULSE @stage_state[1]
@reg_addr = CONST{4,15} @stage_state[1]
// - Add 4
$increment_pc = PULSE (AND @stage_state[1], $reg_ready)	// Increment the program counter too
$pc_updated, @new_pc, $NULL = ADDER_32BIT $increment_pc, (DELAY{2} @reg_data_in), (CONST{32,0x4} 1), 0
// Write back
@reg_data_out = DELAY @new_pc
$reg_enable = DELAY $pc_updated
$reg_write = DELAY $pc_updated
$next_stage = PULSE $pc_updated	// Don't move to decode until PC is updated

// =======================
// === Opcode Decoding ===
// =======================
#array alu_addr 	NUM_GPR_BITS
#array alu_in_dst	NUM_GPR_BITS
#array alu_in_src	NUM_GPR_BITS
#array alu_out  	NUM_GPR_BITS

#display @stage_state[2] "Opcode decode" 1
$decode_enable = OR @stage_state[2:15]
$is_ALU = AND $decode_enable, (NOT @instr[31]), (NOT @instr[30])
$is_CND = AND $decode_enable, (NOT @instr[31]), (DELAY @instr[30]), (NOT @instr[29]), (NOT @instr[28])

// === Handle Undefined Opcodes ===
$is_UNDEF = AND (DELAY $decode_enable), (NOR $is_ALU, $is_CND)
#display $is_UNDEF "UNDEFINED INSTRUCTION!" 0
; $next_instruction = AND @stage_state[1], $is_UNDEF

// === Address/Operand Decoding ===
$no_decode_r = AND $decode_enable, (NOR @instr[31:27])
$decode_start = DELAY $is_ALU
$decode_clear = PULSE @stage_state[4]

$alu_data_rdy, $addr_is_mem, @alu_addr, @alu_in_dst, @alu_in_src = CPU32_ADDRESS_DECODE \
	$decode_start, $decode_clear, (NOT $no_decode_r), 1, @instr, \
	$reg_enable, @reg_addr, $reg_ready, @reg_data_in, \
	$mem_enable, @mem_addr, $mem_ready, @mem_data_in

#display $alu_data_rdy "@alu_addr   = %32x" @alu_addr[31:0]
#display $alu_data_rdy "@alu_in_dst = %32x" @alu_in_dst[31:0]
#display $alu_data_rdy "@alu_in_src = %32x" @alu_in_src[31:0]

// === OPCODES ===
// --- ALU Operations ---
$is_MOV = AND $alu_data_rdy, $is_ALU, (NOT   @instr[29]), (NOT   @instr[28]), (NOT   @instr[27])
$is_AND = AND $alu_data_rdy, $is_ALU, (NOT   @instr[29]), (NOT   @instr[28]), (DELAY @instr[27])
$is_OR  = AND $alu_data_rdy, $is_ALU, (NOT   @instr[29]), (DELAY @instr[28]), (NOT   @instr[27])
$is_XOR = AND $alu_data_rdy, $is_ALU, (NOT   @instr[29]), (DELAY @instr[28]), (DELAY @instr[27])
$is_ADD = AND $alu_data_rdy, $is_ALU, (DELAY @instr[29]), (NOT   @instr[28]), (NOT   @instr[27])
$is_SUB = AND $alu_data_rdy, $is_ALU, (DELAY @instr[29]), (NOT   @instr[28]), (DELAY @instr[27])
$is_CMP = AND $alu_data_rdy, $is_ALU, (DELAY @instr[29]), (DELAY @instr[28]), (NOT   @instr[27])
$is_TST = AND $alu_data_rdy, $is_ALU, (DELAY @instr[29]), (DELAY @instr[28]), (DELAY @instr[27])

// --- MOV ---
#display $is_MOV "MOV *0x%32x = 0x%32x" @alu_addr[31:0], @alu_in_src[31:0]
@alu_out = AND{32} $is_MOV, @alu_in_src
$next_stage = PULSE $is_MOV
// --- AND ---
#display $is_AND "AND *0x%32x = 0x%32x & 0x%32x" @alu_addr[31:0], @alu_in_dst[31:0], @alu_in_src[31:0]
%assign i 0
%rep NUM_GPR_BITS
@alu_out[i] = AND $is_AND, @alu_in_src[i], @alu_in_dst[i]
%assign i i+1
%endrep
$next_stage = PULSE $is_AND
// --- OR  ---
#display $is_OR "OR *0x%32x = 0x%32x | 0x%32x" @alu_addr[31:0], @alu_in_dst[31:0], @alu_in_src[31:0]
%assign i 0
%rep NUM_GPR_BITS
@alu_out[i] = AND $is_OR, (OR @alu_in_src[i], @alu_in_dst[i])
%assign i i+1
%endrep
$next_stage = PULSE (DELAY $is_OR)
// --- XOR ---
#display $is_XOR "XOR *0x%32x = 0x%32x & 0x%32x" @alu_addr[31:0], @alu_in_dst[31:0], @alu_in_src[31:0]
%assign i 0
%rep NUM_GPR_BITS
@alu_out[i] = AND $is_XOR, (XOR @alu_in_src[i], @alu_in_dst[i])
%assign i i+1
%endrep
$next_stage = PULSE (DELAY $is_XOR)
// --- Operation Adder ---
#array alu_adder_op2	32
$next_stage, @alu_out, $flags_C = ADDER_32BIT $alu_adder_pulse, @alu_in_src, @alu_adder_op2, $alu_adder_CF
// --- ADD ---
#display $is_ADD "ADD *0x%32x = 0x%32x + 0x%32x + %i" @alu_addr[31:0], @alu_in_dst[31:0], @alu_in_src[31:0], $flags_C
$flags_C_clear = DELAY{2} $is_ADD
$alu_adder_pulse = PULSE $is_ADD
@alu_adder_op2   = AND{32} $is_ADD, @alu_in_dst
$alu_adder_CF    = AND $is_ADD, $flags_C
// --- SUB ---
#display $is_SUB "SUB *0x%32x = 0x%32x - 0x%32x" @alu_addr[31:0], @alu_in_dst[31:0], @alu_in_src[31:0]
$flags_C_clear = DELAY{3} $is_SUB
$alu_adder_pulse = DELAY (PULSE $is_SUB)
@alu_adder_op2   = AND{32} $is_SUB, (NOT @alu_in_dst)
$alu_adder_CF    = AND $is_SUB, (NOT $flags_C)
// --- CMP --
#display $is_CMP "CMP 0x%32x - 0x%32x" @alu_in_dst[31:0], @alu_in_src[31:0]
$flags_C_clear = DELAY{3} $is_CMP
$alu_adder_pulse = DELAY (PULSE $is_SUB)
@alu_adder_op2   = AND{32} $is_CMP, (NOT @alu_in_dst)
$alu_adder_CF    = AND $is_CMP, (NOT $flags_C)
$alu_nosave = DELAY $is_CMP
// --- TST --
#display $is_TST "TST 0x%32x & 0x%32x" @alu_in_dst[31:0], @alu_in_src[31:0]
%assign i 0
%rep NUM_GPR_BITS
@alu_out[i] = AND $is_TST, @alu_in_src[i], @alu_in_dst[i]
%assign i i+1
%endrep
$alu_nosave = DELAY $is_TST
$next_stage = PULSE $is_TST

// === Save ALU Data ===
// TODO: Handle flag updates
// --- Save --
#display @stage_state[3] "Data save" 1
$alu_save = AND @stage_state[3], $is_ALU
// --- Flags ---
$flags_Z_clear = PULSE $alu_save
$flags_Z = AND $alu_save, (NOR @alu_out)
// --- Save to memory
$_alu_save_mem = AND $alu_save, (NOT $alu_nosave), $addr_is_mem
#display $_alu_save_mem "Memory 0x%32x = 0x%32x" @alu_addr[31:0], @alu_out[31:0]
@mem_addr     = AND{32} $_alu_save_mem, @alu_addr
@mem_data_out = AND{32} $_alu_save_mem, @alu_out
$mem_write  = DELAY $_alu_save_mem
$mem_enable = DELAY $_alu_save_mem
$next_stage = PULSE (AND $_alu_save_mem, $mem_ready)
// --- Save to register
$_alu_save_reg = AND $alu_save, (NOT $alu_nosave), (NOT $addr_is_mem)
#display $_alu_save_reg "Register 0x%4x = 0x%32x" @alu_addr[3:0], @alu_out[31:0]
@reg_addr[3:0] = AND{4} $_alu_save_reg, @alu_addr[3:0]
@reg_data_out = AND{32} $_alu_save_reg, @alu_out
$reg_write = DELAY $_alu_save_reg
$reg_enable = DELAY $_alu_save_reg
$next_stage = PULSE (DELAY{4} $_alu_save_reg)	// wait for update :)
// --- Don't save
$_alu_save_none = AND $alu_save, $alu_nosave
#display $_alu_save_none "Not saving 0x%32x" @alu_out[31:0]
$next_stage = PULSE $_alu_save_none

// === ALU Done ===
#display @stage_state[4] "ALU Complete" 1
$stage_reset = PULSE (AND $is_ALU, @stage_state[4])

; vim: ft=logiccircuit
