An attempt at designing a CPU to be built using virtual logic gates

32-bit opcodes, usually with 8 operation, 4+4 register, 16 operand
All data operations are 32 bits

Special Registers
R12 - Frame Pointer (Suggested)
R13 - Stack Pointer
R14 - Link Register
R15 - PIC base (suggested)

TODO:
- Shifts, sign extended load?
- Replace mmm=110/111 with reversed operand flag (allows 'POP r')

Normal Format:
|---Op---|Dest Src|      Value      |
|oooooooo|RRRRrrrr|vvvvvvvv vvvvvvvv|

Addressing Modes (for most commands)

ooooo000 RRRRrrrr ddddxxxx xxxxxxxx	- <op> d = R, r
ooooo001 RRRRvvvv vvvvvvvv vvvvvvvv	- <op> R, imm20
ooooo010 RRRRssss vvvvvvvv vvvvvvvv	- <op> R, imm16 <<< s
ooooo011 RRRRssss vvvvvvvv vvvvvvvv	- <op> R, imm16s <<< s
ooooo100 RRRRrrrr vvvvvvvv vvvvvvvv	- <op> R, [r + imm16s]
ooooo101 RRRRrrrr iiiissss vvvvvvvv	- <op> R, [r + Ri << s + imm8s]
ooooo110 RRRRrrrr vvvvvvvv vvvvvvvv	- <op> r = R, [PC + imm16s]
ooooo111 RRRRrrrr iiiissss vvvvvvvv	- <op> r = R, [PC + Ri << s + imm8s]

Operations
00000mmm	- MOV op1, op2
00001mmm	- AND op1, op2
00010mmm	- OR op1, op2
00011mmm	- XOR op1, op2
00100mmm	- ADD op1, op2
00101mmm	- SUB op1, op2
00110mmm	- CMP op1, op2
00111mmm	- TEST op1, op2

0100cccc v24	- JMPcc .+imm24s*4
0101cccc v24	- CALLcc .+imm24s*4 (ala BX in ARM)
01100mmm R=0000	- PUSH op2
01100mmm R=0001	- POP op2
01100mmm R=0010 - BSWAP op2	- Big<->Little endian swap
01100mmm R=0011 - BSWAPW op2	- Big<->Little endian swap (low word only)
01100mmm R=01xx - ?
01100mmm R=10xx - ?
01100mmm R=110x - ?
01100mmm R=1110	- MOV PC, op2	- Functionally a jump
01100mmm R=1111	- CALL op2

01101000 00000000 mmmmmmmm vvvvvvvv	- LDF m, v	- Load (Set) Flags (Mask, Value)
    1000 00000001 - ?
    1000 0000001x - ?
    1000 000001xx - ?
    1000 00001xxx - ?
    1000 0001rrrr vvvvvvvv vvvvvvvv	- MOV r, PC+imm16s*4
    1000 001xxxxx - ?
    1000 01xxxxxx - ?
    1000 1xxxxxxx - ?
    1001	- ?
    101x	- ?
    11xx	- ?


011100o0 RRRRrrrr ssssssss ssssssss	- STRW R.o, [r + imm16s]	- Store 16 bits from register
    00o1 RRRRrrrr ssssssss ssssssss	- LDRW R.o, [r + imm16s]	- Load 16 bits to register
    0100 RRRRrrrr ssssssss ssssssss	- LDRWS R, [r + imm16s] 	- Load 16-bits sign extended
    0101 RRRRrrrr ssssssss ssssssss	- LDRWZ R, [r + imm16s] 	- Load 16-bits zero extended
    0110 RRRRrrrr ssssssss ssssssss	- LDRBS R, [r + imm16s] 	- Load 8-bits sign extended
    0111 RRRRrrrr ssssssss ssssssss	- LDRBZ R, [r + imm16s] 	- Load 8-bits zero extended
    1oo0 RRRRrrrr ssssssss ssssssss	- STRB R,o, [r + imm16s]	- Store 8 bits from register
    1oo1 RRRRrrrr ssssssss ssssssss	- LDRB R.o, [r + imm16s]	- Load 8 bits to register

1xxxxxxx	- ?

--- Condition Codes ---
0000 ZF=1	EQ	Equal
0001 ZF=0	NE	Not Equal
0010 CF=1	C	Carry Set
0011 CF=0	NC	Carry Clear
0100 SF=1	S	Negative
0101 SF=0	NS	Positive
0110 OF=1	O	Overflow
0111 OF=0	NO	No Overflow
1000 OF=ZF	GE	Signed Greater or Equal
1001 OF!=ZF	LT	Signed Less
1010 OF=0,ZF=0	GT	Signed Greater
1011 OF=1|ZF=1	LE	Signed Less or Equal
1100 CF=0,ZF=0	A	Above (Unsigned Greater)
1101 CF=1|ZF=1	BE	Below-Equal (Unsigned Less-than)
1110 -  	--	Always
1111 -  	--	Never
