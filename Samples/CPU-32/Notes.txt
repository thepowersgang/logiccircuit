An attempt at designing a CPU to be built using virtual logic gates

32-bit opcodes, usually with 8 operation, 4+4 register, 16 operand
All data operations are 32 bits

Special Registers
R12 - Frame Pointer (Suggested)
R13 - Stack Pointer
R14 - Link Register
R15 - PIC base (suggested)

TODO:
- Shifts

Normal Format:
|---Op---|Dest Src|      Value      |
|oooooooo|RRRRrrrr|vvvvvvvv vvvvvvvv|

Addressing Modes (for most commands)
 > Decoder allows order of operands to be reversed (causing op2 = op2 <op> op1)
ooooo000 RRRRrrrr xxxxxxxx xxxxxxxx	- R = R <op> r
ooooo001 RRRRvvvv vvvvvvvv vvvvvvvv	- R = R <op> imm20
ooooo010 RRRRssss vvvvvvvv vvvvvvvv	- R = R <op> imm16 <<< s
ooooo011 RRRRssss vvvvvvvv vvvvvvvv	- R = R <op> imm16s <<< s
ooooo100 RRRRrrrr vvvvvvvv vvvvvvvv	- R = R <op> [r + imm16s]
ooooo101 RRRRrrrr iiiissss vvvvvvvv	- R = R <op> [r + Ri << s + imm8s]
ooooo110 RRRRxxxx vvvvvvvv vvvvvvvv	- R = R <op> [PC + imm16s]
ooooo111 RRRRxxxx iiiissss vvvvvvvv	- R = R <op> [PC + Ri << s + imm8s]

Operations

== Basic ALU
 > 's': Switch order of operands
 > Saves to immedates are ignored
0s000mmm	- MOV op1, op2
0s001mmm	- AND op1, op2
0s010mmm	- OR op1, op2
0s011mmm	- XOR op1, op2
0s100mmm	- ADD op1, op2
0s101mmm	- SUB op1, op2
0s110mmm	- CMP op1, op2
0s111mmm	- TEST op1, op2

== Conditional jumps
 > 'c': Condition code (see below)
1000cccc v24	- JMPcc .+imm24s*4
1001cccc v24	- CALLcc .+imm24s*4 (ala BX in ARM)
10100mmm R=cccc	- JMPcc op2
10101mmm R=cccc	- CALLcc op2

== General purpose single-operand instructions
10110mmm R=0000	- PUSH op2
         R=0001	- POP op2
         R=0010 - BSWAP op2	- Big<->Little endian swap
         R=0011 - BSWAPW op2	- Big<->Little endian swap (low word only)
         R=01xx - ?
         R=1xxx - ?


== Misc instructions
10111000 00000000 mmmmmmmm vvvvvvvv	- LDF m, v	- Load (Set) Flags (Mask, Value)
    1000 00000001 - ?
    1000 0000001x - ?
    1000 000001xx - ?
    1000 00001xxx - ?
    1000 0001xxxx - ?
    1000 001xxxxx - ?
    1000 01xxxxxx - ?
    1000 1xxxxxxx - ?
    1001	- ?
    101x	- ?
    11xx	- LEA R, op2	- Load Effective Address (NOTE: Modes 0-3 are not memory, so are reused)

== Non-word Loads/Stores
110000o0 RRRRrrrr ssssssss ssssssss	- STRW R.o, [r + imm16s]	- Store 16 bits from register
    00o1 RRRRrrrr ssssssss ssssssss	- LDRW R.o, [r + imm16s]	- Load 16 bits to register
    0100 RRRRrrrr ssssssss ssssssss	- LDRWS R, [r + imm16s] 	- Load 16-bits sign extended
    0101 RRRRrrrr ssssssss ssssssss	- LDRWZ R, [r + imm16s] 	- Load 16-bits zero extended
    0110 RRRRrrrr ssssssss ssssssss	- LDRBS R, [r + imm16s] 	- Load 8-bits sign extended
    0111 RRRRrrrr ssssssss ssssssss	- LDRBZ R, [r + imm16s] 	- Load 8-bits zero extended
    1oo0 RRRRrrrr ssssssss ssssssss	- STRB R,o, [r + imm16s]	- Store 8 bits from register
    1oo1 RRRRrrrr ssssssss ssssssss	- LDRB R.o, [r + imm16s]	- Load 8 bits to register

1111xxxx	- ?
111xxxxx	- ?

--- Condition Codes ---
0000 ZF=1	EQ	Equal
0001 ZF=0	NE	Not Equal
0010 CF=1	C	Carry Set
0011 CF=0	NC	Carry Clear
0100 SF=1	S	Negative
0101 SF=0	NS	Positive
0110 OF=1	O	Overflow
0111 OF=0	NO	No Overflow
1000 OF=ZF	GE	Signed Greater or Equal
1001 OF!=ZF	LT	Signed Less
1010 OF=0,ZF=0	GT	Signed Greater
1011 OF=1|ZF=1	LE	Signed Less or Equal
1100 CF=0,ZF=0	A	Above (Unsigned Greater)
1101 CF=1|ZF=1	BE	Below-Equal (Unsigned Less-than)
1110 -  	--	Always
1111 -  	--	Never
